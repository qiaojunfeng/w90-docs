{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"user_guide/introduction/","title":"Introduction","text":""},{"location":"user_guide/introduction/#getting-help","title":"Getting Help","text":"<p>The latest release of <code>wannier90</code>\u00a0and documentation can always be found at https://www.wannier.org.</p> <p>The development version may be cloned/downloaded from the official repository of the <code>wannier90</code>\u00a0code on GitHub (see https://github.com/wannier-developers/wannier90).</p> <p>There is a <code>wannier90</code>\u00a0mailing list for discussing issues in the development, theory, coding and algorithms pertinent to MLWF. You can register for this mailing list by following the links at https://www.wannier.org/forum.html. Alternatively, for technical issues about the <code>wannier90</code>\u00a0code, check the official repository of <code>wannier90</code>\u00a0on GitHub where you may raise issues or ask questions about about its functionalities.</p> <p>Finally, many frequently asked questions are answered in Appendix\u00a02. An expanded FAQ session may be found on the Wiki page of the GitHub repository at https://github.com/wannier-developers/wannier90/wiki/FAQ.</p>"},{"location":"user_guide/introduction/#citations","title":"Citations","text":"<p>We ask that you acknowledge the use of <code>wannier90</code>\u00a0in any publications arising from the use of this code through the following reference</p> <p>[ref] G. Pizzi, V. Vitale, R. Arita, S. Bl\u00fcgel, F. Freimuth, G. G\u00e9ranton, M. Gibertini, D. Gresch, C. Johnson, T. Koretsune, J. Iba\u00f1ez-Azpiroz, H. Lee, J.M. Lihm, D. Marchand, A. Marrazzo, Y. Mokrousov, J.I. Mustafa, Y. Nohara, Y. Nomura, L. Paulatto, S. Ponc\u00e9, T. Ponweiser, J. Qiao, F. Th\u00f6le, S.S. Tsirkin, M. Wierzbowska, N. Marzari, D. Vanderbilt, I. Souza, A.A. Mostofi, J.R. Yates, Wannier90 as a community code: new features and applications, J. Phys. Cond. Matt. 32, 165902 (2020) https://doi.org/10.1088/1361-648X/ab51ff</p> <p>If you are using versions 2.x of the code, cite instead:</p> <p>[ref] A.\u00a0A.\u00a0Mostofi, J.\u00a0R.\u00a0Yates, G.\u00a0Pizzi, Y.-S.\u00a0Lee, I.\u00a0Souza, D.\u00a0Vanderbilt and N.\u00a0Marzari, An updated version of <code>wannier90</code>: A Tool for Obtaining Maximally-Localised Wannier Functions, Comput. Phys. Commun. 185, 2309 (2014) http://dx.doi.org/10.1016/j.cpc.2014.05.003</p> <p>It would also be appropriate to cite the original articles:</p> <p>Maximally localized generalized Wannier functions for composite energy bands, N. Marzari and D. Vanderbilt, Phys. Rev. B 56, 12847 (1997)</p> <p>and</p> <p>Maximally localized Wannier functions for entangled energy bands, I. Souza, N. Marzari and D. Vanderbilt, Phys. Rev. B 65, 035109 (2001)</p>"},{"location":"user_guide/introduction/#credits","title":"Credits","text":"<p>The Wannier90 Developer Group includes Giovanni Pizzi (EPFL, CH), Valerio Vitale (Cambridge, GB), David Vanderbilt (Rutgers University, US), Nicola Marzari (EPFL, CH), Ivo Souza (Universidad del Pais Vasco, ES), Arash A. Mostofi (Imperial College London, GB), and Jonathan R. Yates (University of Oxford, GB).</p> <p>The present release of <code>wannier90</code>\u00a0was written by the Wannier90 Developer Group together with Ryotaro Arita (Riken and U. Tokyo, JP), Stefan Bl\u00fcgel (FZ J\u00fclich, DE), Frank Freimuth (FZ J\u00fclich, DE), Guillame G\u00e9ranton (FZ J\u00fclich, DE), Marco Gibertini (EPFL and University of Geneva, CH), Dominik Gresch (ETHZ, CH), Charles Johnson (Imperial College London, GB), Takashi Koretsune (Tohoku University and JST PRESTO, JP), Julen Iba\u00f1ez-Azpiroz (Universidad del Pais Vasco, ES), Hyungjun Lee (EPFL, CH), Jae-Mo Lihm (Seoul National University, KR), Daniel Marchand (EPFL, CH), Antimo Marrazzo (EPFL, CH), Yuriy Mokrousov (FZ J\u00fclich, DE), Jamal I. Mustafa (UC Berkeley, USA), Yoshiro Nohara (Tokyo, JP), Yusuke Nomura (U. Tokyo, JP), Lorenzo Paulatto (Sorbonne Paris, FR), Samuel Ponc\u00e9 (Oxford University, GB), Thomas Ponweiser (RISC Software GmbH, AT), Florian Th\u00f6le (ETHZ, CH), Stepan Tsirkin (Universidad del Pais Vasco, ES), Ma\u0142gorzata Wierzbowska (Polish Academy of Science, PL).</p> <p>Contributors to the code include: Daniel Aberg (w90pov code), Lampros Andrinopoulos (w90vdw code), Pablo Aguado Puente (gyrotropic routines), Raffaello Bianco (k-slice plotting), Marco Buongiorno Nardelli (dosqc v1.0 subroutines upon which transport.f90 is based), Stefano De Gironcoli (pw2wannier90.x interface to Quantum ESPRESSO), Pablo Garcia Fernandez (matrix elements of the position operator), Nicholas D. M. Hine (w90vdw code), Young-Su Lee (specialised Gamma point routines and transport), Antoine Levitt (preconditioning), Graham Lopez (extension of pw2wannier90 to add terms needed for orbital magnetisation), Radu Miron (constrained centres), Nicolas Poilvert (transport routines), Michel Posternak (original plotting routines), Rei Sakuma (Symmetry-adapted Wannier functions), Gabriele Sclauzero (disentanglement in spheres in k-space), Matthew Shelley (transport routines), Christian Stieger (routine to print the U matrices), David Strubbe (various bugfixes/improvements), Timo Thonhauser (extension of pw2wannier90 to add terms needed for orbital magnetisation), Junfeng Qiao (spin Hall conductivity, projectability-disentangled Wannier functions).</p> <p>We also acknowledge individuals not already mentioned above who participated in the first Wannier90 community meeting (San Sebastian, 2016) for useful discussions: Daniel Fritsch, Victor Garcia Suarez, Jan-Philipp Hanke, Ji Hoon Ryoo, J\u00fcrg Hutter, Javier Junquera, Liang Liang, Michael Obermeyer, Gianluca Prandini, Paolo Umari.</p> <p><code>wannier90</code>\u00a0Version 2.x was written by: Arash A. Mostofi, Giovanni Pizzi, Ivo Souza, Jonathan R. Yates. <code>wannier90</code>\u00a0Version 1.0 was written by: Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee. <code>wannier90</code>\u00a0is based on the Wannier Fortran 77 code written for isolated bands by Nicola Marzari and David Vanderbilt and for entangled bands by Ivo Souza, Nicola Marzari, and David Vanderbilt.</p> <p><code>wannier90</code>\u00a0\u00a9\u00a02007-2020 The Wannier Developer Group and individual contributors</p>"},{"location":"user_guide/introduction/#licence","title":"Licence","text":"<p>All the material in this distribution is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>"},{"location":"user_guide/appendices/faq/","title":"Frequently Asked Questions","text":""},{"location":"user_guide/appendices/faq/#general-questions","title":"General Questions","text":""},{"location":"user_guide/appendices/faq/#what-is-wannier90","title":"What is <code>wannier90</code>?","text":"<p><code>wannier90</code>\u00a0is a computer package, written in Fortran90, for obtaining maximally-localised Wannier functions, using them to calculate bandstructures, Fermi surfaces, dielectric properties, sparse Hamiltonians and many things besides.</p>"},{"location":"user_guide/appendices/faq/#where-can-i-get-wannier90","title":"Where can I get <code>wannier90</code>?","text":"<p>The most recent release of <code>wannier90</code>\u00a0is always available on our website http://www.wannier.org.</p>"},{"location":"user_guide/appendices/faq/#where-can-i-get-the-most-recent-information-about-wannier90","title":"Where can I get the most recent information about <code>wannier90</code>?","text":"<p>The latest news about <code>wannier90</code>\u00a0can be followed on our website http://www.wannier.org.</p>"},{"location":"user_guide/appendices/faq/#is-wannier90-free","title":"Is <code>wannier90</code>\u00a0free?","text":"<p>Yes! <code>wannier90</code>\u00a0is available for use free-of-charge under the GNU General Public Licence. See the file <code>LICENSE</code> that comes with the <code>wannier90</code>\u00a0distribution or the GNU hopepage at http://www.gnu.org.</p>"},{"location":"user_guide/appendices/faq/#getting-help","title":"Getting Help","text":""},{"location":"user_guide/appendices/faq/#is-there-a-tutorial-available-for-wannier90","title":"Is there a Tutorial available for <code>wannier90</code>?","text":"<p>Yes! The <code>examples</code> directory of the <code>wannier90</code>\u00a0distribution contains input files for a number of tutorial calculations. The <code>doc</code> directory contains the accompanying tutorial handout.</p>"},{"location":"user_guide/appendices/faq/#where-do-i-get-support-for-wannier90","title":"Where do I get support for <code>wannier90</code>?","text":"<p>There are a number of options:</p> <ol> <li> <p>The <code>wannier90</code>\u00a0User Guide, available in the <code>doc</code> directory of the     distribution, and from the webpage     (http://www.wannier.org/user_guide.html)</p> </li> <li> <p>The <code>wannier90</code>\u00a0webpage for the most recent announcements     (http://www.wannier.org)</p> </li> <li> <p>The <code>wannier90</code>\u00a0mailing list (see     http://www.wannier.org/forum.html)</p> </li> </ol>"},{"location":"user_guide/appendices/faq/#is-there-a-mailing-list-for-wannier90","title":"Is there a mailing list for <code>wannier90</code>?","text":"<p>Yes! You need to register: go to http://www.wannier.org/forum.html and follow the instructions.</p>"},{"location":"user_guide/appendices/faq/#providing-help-finding-and-reporting-bugs","title":"Providing Help: Finding and Reporting Bugs","text":""},{"location":"user_guide/appendices/faq/#i-think-i-found-a-bug-how-do-i-report-it","title":"I think I found a bug. How do I report it?","text":"<ul> <li> <p>Check and double-check. Make sure it's a bug.</p> </li> <li> <p>Check that it is a bug in <code>wannier90</code>\u00a0and not a bug in the software     interfaced to <code>wannier90</code>.</p> </li> <li> <p>Check that you're using the latest version of <code>wannier90</code>.</p> </li> <li> <p>Send us an email. Make sure to describe the problem and to attach     all input and output files relating to the problem that you have     found.</p> </li> </ul>"},{"location":"user_guide/appendices/faq/#i-have-got-an-idea-how-do-i-report-a-wish","title":"I have got an idea! How do I report a wish?","text":"<p>We're always happy to listen to suggestions. Email your idea to the <code>wannier90</code>\u00a0developers.</p>"},{"location":"user_guide/appendices/faq/#i-want-to-help-how-can-i-contribute-to-wannier90","title":"I want to help! How can I contribute to <code>wannier90</code>?","text":"<p>Great! There's always plenty of functionality to add. Email us to let us know about the functionality you'd like to contribute.</p>"},{"location":"user_guide/appendices/faq/#i-like-wannier90-should-i-donate-anything-to-its-authors","title":"I like <code>wannier90</code>! Should I donate anything to its authors?","text":"<p>Our Swiss bank account number is... just kidding! There is no need to donate anything, please just cite our paper in any publications that arise from your use of <code>wannier90</code>:</p> <p>[ref] G. Pizzi, V. Vitale, R. Arita, S. Bl\u00fcgel, F. Freimuth, G. G\u00e9ranton, M. Gibertini, D. Gresch, C. Johnson, T. Koretsune, J. Iba\u00f1ez-Azpiroz, H. Lee, J.M. Lihm, D. Marchand, A. Marrazzo, Y. Mokrousov, J.I. Mustafa, Y. Nohara, Y. Nomura, L. Paulatto, S. Ponc\u00e9, T. Ponweiser, J. Qiao, F. Th\u00f6le, S.S. Tsirkin, M. Wierzbowska, N. Marzari, D. Vanderbilt, I. Souza, A.A. Mostofi, J.R. Yates,\\ Wannier90 as a community code: new features and applications, J. Phys. Cond. Matt. 32, 165902 (2020)\\ https://doi.org/10.1088/1361-648X/ab51ff</p> <p>If you are using versions 2.x of the code, cite instead:</p> <p>[ref] A.\u00a0A.\u00a0Mostofi, J.\u00a0R.\u00a0Yates, G.\u00a0Pizzi, Y.-S.\u00a0Lee, I.\u00a0Souza, D.\u00a0Vanderbilt and N.\u00a0Marzari,\\ An updated version of <code>wannier90</code>: A Tool for Obtaining Maximally-Localised Wannier Functions, Comput. Phys. Commun. 185, 2309 (2014)\\ http://doi.org/10.1016/j.cpc.2014.05.003</p>"},{"location":"user_guide/appendices/faq/#installation","title":"Installation","text":""},{"location":"user_guide/appendices/faq/#how-do-i-install-wannier90","title":"How do I install <code>wannier90</code>?","text":"<p>Follow the instructions in the file <code>README.install</code> in the main directory of the <code>wannier90</code>\u00a0distribution.</p>"},{"location":"user_guide/appendices/faq/#are-there-wannier90-binaries-available","title":"Are there <code>wannier90</code>\u00a0binaries available?","text":"<p>Not at present.</p>"},{"location":"user_guide/appendices/faq/#is-there-anything-else-i-need","title":"Is there anything else I need?","text":"<p>Yes. <code>wannier90</code>\u00a0works on top of an electronic structure calculation.</p> <p>At the time of writing there are public, fully functioning, interfaces between <code>wannier90</code>\u00a0and [pwscf]{.smallcaps}, abinit (http://www.abinit.org), siesta (http://www.icmab.es/siesta/), VASP (https://www.vasp.at), Wien2k (http://www.wien2k.at), fleur (http://www.fleur.de), OpenMX (http://www.openmx-square.org/), GPAW (https://wiki.fysik.dtu.dk/gpaw/).</p> <p>To use <code>wannier90</code>\u00a0in combination with [pwscf]{.smallcaps}\u00a0code (a plane-wave, pseudopotential, density-functional theory code, which is part of the <code>quantum-espresso</code> package) you will need to download [pwscf]{.smallcaps}\u00a0from the webpage http://www.quantum-espresso.org. Then compile [pwscf]{.smallcaps}\u00a0and the <code>wannier90</code>\u00a0interface program <code>pw2wannier90</code>. For instructions, please refer to the documentation that comes with the <code>quantum-espresso</code> distribution.</p> <p>For examples of how to use [pwscf]{.smallcaps}\u00a0and <code>wannier90</code>\u00a0in conjunction with each other, see the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/appendices/utilities/","title":"Utilities","text":""},{"location":"user_guide/appendices/utilities/#utilities","title":"Utilities","text":"<p>The <code>wannier90</code>\u00a0code is shipped with a few utility programs that may be useful in some occasions. In this chapter, we describe their use.</p>"},{"location":"user_guide/appendices/utilities/#kmeshpl","title":"<code>kmesh.pl</code>","text":"<p>The <code>wannier90</code>\u00a0code requires the definition of a full Monkhorst--Pack grid of \\(k\\) points. In the input file the size of this mesh is given by means of the <code>mp_grid</code> variable. E.g., setting</p> <pre><code>mp_grid = 4 4 4\n</code></pre> <p>tells <code>wannier90</code>\u00a0that we want to use a \\(4\\times 4\\times 4\\) \\(k\\) grid.</p> <p>One has then to specify (inside the <code>kpoints</code> block in the the <code>seedname.win</code> file) the list of \\(k\\) points of the grid. Here, the <code>kmesh.pl</code> Perl script becomes useful, being able to generate the required list.</p> <p>The script can be be found in the <code>utility</code> directory of the <code>wannier90</code>\u00a0distribution. To use it, simply type:</p> <pre><code>./kmesh.pl nx ny nz\n</code></pre> <p>where <code>nx</code>, <code>ny</code> and <code>nz</code> define the size of the Monkhorst--Pack grid that we want to use (for instance, in the above example of the \\(4\\times 4\\times 4\\) \\(k\\) grid, <code>nx</code>\\(=\\)<code>ny</code>\\(=\\)<code>nz</code>\\(=\\)<code>&lt;!-- --&gt;</code>4).</p> <p>This produces on output the list of \\(k\\) points in Quantum Espresso format, where (apart from a header) the first three columns of each line are the \\(k\\) coordinates, and the fourth column is the weight of each \\(k\\) point. This list can be used to create the input file for the ab-initio <code>nscf</code> calculation.</p> <p>If one wants instead to generate the list of the \\(k\\) coordinates without the weight (in order to copy and paste the output inside the <code>seedname.win</code> file), one simply has to provide a fourth argument on the command line. For instance, for a \\(4\\times 4\\times 4\\) \\(k\\) grid, use</p> <pre><code>./kmesh.pl 4 4 4 wannier\n</code></pre> <p>and then copy the output inside the in the <code>kpoints</code> block in the <code>seedname.win</code> file.</p> <p>We suggest to always use this utility to generate the \\(k\\) grids. This allows to provide the \\(k\\) point coordinates with the accuracy required by <code>wannier90</code>, and moreover it makes sure that the \\(k\\) grid used in the ab-initio code and in <code>wannier90</code>\u00a0are the same.</p>"},{"location":"user_guide/appendices/utilities/#ttw90chk2chkxsecw90chk2chk-labelsecw90chk2chk","title":"\\(\\tt{w90chk2chk.x}\\)[]{#sec:w90chk2chk label=\"sec:w90chk2chk\"}","text":"<p>During the calculation of the Wannier functions, <code>wannier90</code>\u00a0produces a <code>.chk</code> file that contains some information to restart the calculation.</p> <p>This file is also required by the <code>postw90</code>\u00a0code. In particular, the <code>postw90</code>\u00a0code requires at least the <code>.chk</code> file, the <code>.win</code> input file, and (almost always) the <code>.eig</code> file. Specific modules may require further files: see the documentation of each module.</p> <p>However, the <code>.chk</code> file is written in a machine-dependent format. If one wants to run <code>wannier90</code>\u00a0on a machine, and then continue the calculation with <code>postw90</code>\u00a0on a different machine (or with <code>postw90</code>\u00a0compiled with a different compiler), the file has to be converted first in a machine-independent \"formatted\" format on the first machine, and then converted back on the second machine.</p> <p>To this aim, use the <code>w90chk2chk.x</code> executable. Note that this executable is not compiled by default: you can obtain it by executing</p> <pre><code>make w90chk2chk\n</code></pre> <p>in the main <code>wannier90</code>\u00a0directory.</p> <p>A typical use is the following:</p> <ol> <li> <p>Calculate the Wannier functions with <code>wannier90</code></p> </li> <li> <p>At the end of the calculation you will find a <code>seedname.chk</code> file.     Run (in the folder with this file) the command</p> <pre><code>w90chk2chk.x -export seedname\n</code></pre> <p>or equivalently</p> <pre><code>w90chk2chk.x -u2f seedname\n</code></pre> <p>(replacing <code>seedname</code> with the seedname of your calculation).</p> <p>This command reads the <code>seedname.chk</code> file and creates a formatted file <code>seedname.chk.fmt</code> that is safe to be transferred between different machines.</p> </li> <li> <p>Copy the <code>seedname.chk.fmt</code> file (together with the <code>seedname.win</code>     and <code>seedname.eig</code> files) on the machine on which you want to run     <code>postw90</code>.</p> </li> <li> <p>On this second machine (after having compiled <code>w90chk2chk.x</code>) run</p> <pre><code>w90chk2chk.x -import seedname\n</code></pre> <p>or equivalently</p> <pre><code>w90chk2chk.x -f2u seedname\n</code></pre> <p>This command reads the <code>seedname.chk.fmt</code> file and creates an unformatted file <code>seedname.chk</code> ready to be used by <code>postw90</code>.</p> </li> <li> <p>Run the <code>postw90</code>\u00a0code.</p> </li> </ol>"},{"location":"user_guide/appendices/utilities/#sec:pl_assessment","title":"\\(\\tt{PL\\_assessment}\\)","text":"<p>The function of this utility is to assess the length of a principal layer (in the context of a Landauer-Buttiker quantum conductance calculation) of a periodic system using a calculation on a single unit cell with a dense k-point mesh.</p> <p>The utility requires the real-space Hamiltonian in the MLWF basis, <code>seedname_hr.dat</code>.</p> <p>The <code>seedname_hr.dat</code> file should be copied to a directory containing executable for the utility. Within that directory, run:</p> <pre><code>\\$&gt; ./PL_assess.x  nk1 nk2 nk3 num_wann\n</code></pre> <p>where:</p> <p><code>nk1</code> is the number of k-points in x-direction <code>nk2</code> is the number of k-points in y-direction <code>nk3</code> is the number of k-points in z-direction <code>num_wann</code> is the number of wannier functions of your system</p> <p>e.g.,</p> <pre><code>\\$&gt; ./PL_assess.x  1 1 20 16\n</code></pre> <p>Note that the current implementation only allows for a single k-point in the direction transverse to the transport direction.</p> <p>When prompted, enter the seedname.</p> <p>The programme will return an output file <code>seedname_pl.dat</code>, containing four columns</p> <ol> <li> <p>Unit cell number, \\(R\\)</p> </li> <li> <p>Average 'on-site' matrix element between MLWFs in the home unit     cell, and the unit cell \\(R\\) lattice vectors away</p> </li> <li> <p>Standard devaition of the quantity in (2)</p> </li> <li> <p>Maximum absolute value in (2)</p> </li> </ol>"},{"location":"user_guide/appendices/utilities/#sec:w90vdw","title":"\\(\\tt{w90vdw}\\)","text":"<p>This utility provides an implementation of a method for calculating van der Waals energies based on the idea of density decomposition via MLWFs.</p> <p>For theoretical details, please see the following publication and references therein:</p> <p>Lampros Andrinopoulos, Nicholas D. M. Hine and Arash A. Mostofi, \"Calculating dispersion interactions using maximally localized Wannier functions\", J. Chem. Phys. 135, 154105 (2011).</p> <p>For further details of this program, please see the documentation in <code>utility/w90vdw/doc/</code> and the related examples in <code>utility/w90vdw/examples/</code>.</p>"},{"location":"user_guide/appendices/utilities/#sec:w90pov","title":"\\(\\tt{w90pov}\\)","text":"<p>An utility to create Pov files (to render the Wannier functions using the PovRay utility) is provided inside <code>utility/w90pov</code>.</p> <p>Please refer to the documentation inside <code>utility/w90pov/doc</code> for more information.</p>"},{"location":"user_guide/appendices/utilities/#sec:k_mapper","title":"\\(\\tt{k\\_mapper.py}\\)","text":"<p>The <code>wannier90</code>\u00a0code requires the definition of a full Monkhorst--Pack grid of \\(\\mathbf{k}\\)-vectors, which can be obtained by means of the <code>kmesh.pl</code> utility. In order to perform a GW calculation with the Yambo code, you need to perform a nscf calculation on a grid in the irreducible BZ. Moreover, you may need a finer grid to converge the GW calculation than what you need to interpolate the band structure. The <code>k_mapper.py</code> tools helps in finding the \\(\\mathbf{k}\\)-vectors indexes of a full grid needed for interpolation into the reduced grid needed for the GW calculation with Yambo. Usage:</p> <p><code>path/k_mapper.py nx ny nz QE_nscf_output</code></p> <p>where <code>path</code> is the path of <code>utility</code> folder, <code>QE_nscf_output</code> is the path of the QE nscf output file given to Yambo.</p>"},{"location":"user_guide/appendices/utilities/#ttgw2wannier90py","title":"\\(\\tt{gw2wannier90.py}\\)","text":"<p>This utility allows to sort in energy the input data of <code>wannier90</code> (e.g. overlap matrices and energy eigenvalues). <code>gw2wannier90.py</code> allows to use <code>wannier90</code> at the \\(G_0W_0\\) level, where quasi-particle corrections can change the energy ordering of eigenvalues (Some <code>wannier90</code> modules require states to be ordered in energy). Usage:</p> <p><code>path/gw2wannier90.py seedname options</code> where <code>path</code> is the path of <code>utility</code> folder.</p> <p>Available options are:</p> <pre><code>mmn, amn, spn, unk, uhu, uiu,\nspn_formatted, unk_formatted, uhu_formatted, uiu_formatted,\nwrite_formatted\n</code></pre> <p>If no options are specified, all the files (<code>mmn, amn, spn, UNK, uHu, uIu</code>) are considered.</p> <p>Binary (unformatted Fortran) files are supported, though not reccommended, since they are compiler-dependent. A safer choice is to use (bigger) formatted files, with options:</p> <p><code>spn_formatted, uiu_formatted, uhu_formatted, unk_formatted</code></p> <p>In default, the output format is the same as the input format. To generate formatted files with unformatted input, use option: <code>write_formatted</code> []{#sec:w90aaa label=\"sec:w90aaa\"}</p>"},{"location":"user_guide/appendices/utilities/#ttw90spn2spnxsecw90spn2spn-labelsecw90spn2spn","title":"\\(\\tt{w90spn2spn.x}\\)[]{#sec:w90spn2spn label=\"sec:w90spn2spn\"}","text":"<p>The interface between ab-initio code and <code>wannier90</code>\u00a0(e.g. <code>pw2wannier90.x</code>) can produce a <code>.spn</code> file that is used by <code>postw90</code>\u00a0to calculate some spin related quantities.</p> <p>The <code>.spn</code> file can be written in a machine-dependent or a machine-independent format depending on the input parameter <code>spn_formatted</code> (the default is <code>false</code> which means the <code>.spn</code> file is machine-dependent) of the <code>pw2wannier90.x</code>. If a <code>.spn</code> file has been generated on a machine with machine-dependent format, and then one wants to continue the calculation with <code>postw90</code>\u00a0on a different machine (or with <code>postw90</code>\u00a0compiled with a different compiler), the file has to be converted first in a machine-independent \"formatted\" format on the first machine.</p> <p>To this aim, use the <code>w90spn2spn.x</code> executable. Note that this executable is not compiled by default: you can obtain it by executing</p> <pre><code>make w90spn2spn\n</code></pre> <p>in the main <code>wannier90</code>\u00a0directory.</p> <p>A typical use is the following:</p> <ol> <li> <p>Calculate the <code>.spn</code> file, e.g. by <code>pw2wannier90.x</code></p> </li> <li> <p>At the end of the calculation you will find a <code>seedname.spn</code> file.     If the file is \"unformatted\", run (in the folder with this file) the     command</p> <pre><code>    w90spn2spn.x -export seedname\n</code></pre> <p>or equivalently</p> <pre><code>    w90spn2spn.x -u2f seedname\n</code></pre> <p>(replacing <code>seedname</code> with the seedname of your calculation).</p> <p>This command reads the <code>seedname.spn</code> file and creates a formatted file <code>seedname.spn.fmt</code> that is safe to be transferred between different machines.</p> </li> <li> <p>Copy the <code>seedname.spn.fmt</code> file on the machine on which you want to     run <code>postw90</code>.</p> </li> <li> <p>On this second machine (after having compiled <code>w90spn2spn.x</code>) run</p> <pre><code>    w90spn2spn.x -import seedname\n</code></pre> <p>or equivalently</p> <pre><code>    w90spn2spn.x -f2u seedname\n</code></pre> <p>This command reads the <code>seedname.spn.fmt</code> file and creates an unformatted file <code>seedname.spn</code> ready to be used by <code>postw90</code>.</p> </li> <li> <p>Run the <code>postw90</code>\u00a0code.</p> </li> </ol> <p>Note if <code>spn_formatted</code> is set to <code>true</code> in both <code>pw2wannier90.x</code> and <code>postw90</code>\u00a0input files, then the <code>.spn</code> file will be written and read as \"formatted\", so <code>w90spn2spn.x</code> is not needed. However, if an \"unformatted\" <code>seedname.spn</code> has been created and you do not want to rerun <code>pw2wannier90.x</code>, then <code>w90spn2spn.x</code> can be useful. Also, once a \"formatted\" <code>seedname.spn</code> has been generated, the step 4 can be skipped if <code>spn_formatted</code> is set to <code>true</code> in <code>postw90</code>\u00a0input file <code>seedname.win</code>.</p>"},{"location":"user_guide/appendices/utilities/#write_pdwf_projectorspy","title":"<code>write_pdwf_projectors.py</code>","text":"<p>A python script to extract projectors from a <code>UPF</code> file and write them into a <code>pw2wannier90.x</code>-recognizable <code>dat</code> file, which can be used to compute <code>amn</code> using pseudo-atomic orbital projection.</p> <p>Usage:</p> <p><code>path/write_pdwf_projectors.py UPF_filename</code></p> <p>where <code>path</code> is the path of <code>utility</code> folder, <code>UPF_filename</code> is the path of a <code>UPF</code> file.</p> <p>The script serves as a reference for writing the <code>dat</code> file, you can generate your own pseudo-atomic orbitals by some other codes and use them to compute <code>amn</code>.</p>"},{"location":"user_guide/postw90/berry/","title":"Overview of the <code>berry</code> module","text":"<p>The <code>berry</code> module of <code>postw90</code> is called by setting <code>berry = true</code> and choosing one or more of the available options for <code>berry_task</code>. The routines in the <code>berry</code> module which compute the \\(k\\)-space Berry curvature, orbital magnetization and spin Hall conductivity are also called when <code>kpath = true</code> and <code>kpath_task = {curv,morb,shc}</code>, or when <code>kslice = true</code> and <code>kslice_task = {curv,morb,shc}</code>.</p>"},{"location":"user_guide/postw90/berry/#background-berry-connection-and-curvature","title":"Background: Berry connection and curvature","text":"<p>The Berry connection is defined in terms of the cell-periodic Bloch states \\(\\vert u_{n{\\bf k}}\\rangle=e^{-i{\\bf k}\\cdot{\\bf r}}\\vert \\psi_{n{\\bf k}}\\rangle\\) as \\(\\({\\bf A}_n({\\bf k})=\\langle u_{n{\\bf k}}\\vert i\\bm{\\nabla}_{\\bf k}\\vert u_{n{\\bf k}}\\rangle,\\)\\) and the Berry curvature is the curl of the connection, \\(\\(\\bm{\\Omega}_n({\\bf k})=\\bm{\\nabla}_{\\bf k}\\times {\\bf A}_n({\\bf k})= -{\\rm Im} \\langle \\bm{\\nabla}_{\\bf k} u_{n{\\bf k}}\\vert \\times \\vert\\bm{\\nabla}_{\\bf k} u_{n{\\bf k}}\\rangle.\\)\\) These two quantities play a central role in the description of several electronic properties of crystals\u00a0<sup>1</sup>. In the following we will work with a matrix generalization of the Berry connection, \\(\\({\\bf A}_{nm}({\\bf k})=\\langle u_{n{\\bf k}}\\vert i\\bm{\\nabla}_{\\bf k}\\vert u_{m{\\bf k}}\\rangle={\\bf A}_{mn}^*({\\bf k}), \\label{eq:berry-connection-matrix}\\)\\) and write the curvature as an antisymmetric tensor, \\(\\(\\label{eq:curv} \\Omega_{n,\\alpha\\beta}({\\bf k}) =\\epsilon_{\\alpha\\beta\\gamma} \\Omega_{n,\\gamma}({\\bf k})=-2{\\rm Im}\\langle  \\nabla_{k_\\alpha} u_{n\\bf k}\\vert \\nabla_{k_\\beta} u_{n\\bf k}\\rangle.\\)\\)</p>"},{"location":"user_guide/postw90/berry/#berry_taskkubo-optical-conductivity-and-joint-density-of-states","title":"<code>berry_task=kubo</code>: optical conductivity and joint density of states","text":"<p>The Kubo-Greenwood formula for the optical conductivity of a crystal in the independent-particle approximation reads \\(\\(\\sigma_{\\alpha\\beta}(\\hbar\\omega)=\\frac{ie^2\\hbar}{N_k\\Omega_c} \\sum_{\\bf k}\\sum_{n,m} \\frac{f_{m{\\bf k}}-f_{n{\\bf k}}}      {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}} \\frac{\\langle\\psi_{n{\\bf k}}\\vert v_\\alpha\\vert\\psi_{m{\\bf k}}\\rangle       \\langle\\psi_{m{\\bf k}}\\vert v_\\beta\\vert\\psi_{n{\\bf k}}\\rangle} {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-(\\hbar\\omega+i\\eta)}.\\)\\) Indices \\(\\alpha,\\beta\\) denote Cartesian directions, \\(\\Omega_c\\) is the cell volume, \\(N_k\\) is the number of \\(k\\)-points used for sampling the Brillouin zone, and \\(f_{n{\\bf k}}=f(\\varepsilon_{n{\\bf k}})\\) is the Fermi-Dirac distribution function. \\(\\hbar\\omega\\) is the optical frequency, and \\(\\eta&gt;0\\) is an adjustable smearing parameter with units of energy.</p> <p>The off-diagonal velocity matrix elements can be expressed in terms of the connection matrix\u00a0<sup>2</sup>, \\(\\(\\label{eq:velocity_mat} \\langle\\psi_{n{\\bf k}}\\vert {\\bf v} \\vert\\psi_{m{\\bf k}}\\rangle= -\\frac{i}{\\hbar}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}) {\\bf A}_{nm}({\\bf k})\\,\\,\\,\\,\\,\\,\\,\\,(m\\not= n).\\)\\) The conductivity becomes \\(\\(\\begin{aligned} \\label{eq:sig-bz} \\sigma_{\\alpha\\beta}(\\hbar\\omega)&amp;= \\frac{1}{N_k}\\sum_{\\bf k}\\sigma_{{\\bf k},\\alpha\\beta}(\\hbar\\omega)\\\\ \\label{eq:sig-k} \\sigma_{{\\bf k},\\alpha\\beta}(\\hbar\\omega)&amp;=\\frac{ie^2}{\\hbar\\Omega_c}\\sum_{n,m} (f_{m{\\bf k}}-f_{n{\\bf k}}) \\frac{\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}} {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-(\\hbar\\omega+i\\eta)} A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}). \\end{aligned}\\)\\)</p> <p>Let us decompose it into Hermitian (dissipative) and anti-Hermitean (reactive) parts. Note that \\(\\(\\label{eq:lorentzian} \\overline{\\delta}(\\varepsilon)=\\frac{1}{\\pi}{\\rm Im} \\left[\\frac{1}{\\varepsilon-i\\eta}\\right],\\)\\) where \\(\\overline{\\delta}\\) denotes a \"broadended\" delta-function. Using this identity we find for the Hermitean part \\(\\(\\label{eq:sig-H} \\sigma_{{\\bf k},\\alpha\\beta}^{\\rm H}(\\hbar\\omega)=-\\frac{\\pi e^2}{\\hbar\\Omega_c} \\sum_{n,m}(f_{m{\\bf k}}-f_{n{\\bf k}}) (\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}) A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}) \\overline{\\delta}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-\\hbar\\omega).\\)\\) Improved numerical accuracy can be achieved by replacing the Lorentzian ([eq:lorentzian]{reference-type=\"ref\" reference=\"eq:lorentzian\"}) with a Gaussian, or other shapes. The analytical form of \\(\\overline{\\delta}(\\varepsilon)\\) is controlled by the keyword <code>[kubo_]smr_type</code>.</p> <p>The anti-Hermitean part of Eq.\u00a0([eq:sig-k]{reference-type=\"ref\" reference=\"eq:sig-k\"}) is given by \\(\\(\\label{eq:sig-AH} \\sigma_{{\\bf k},\\alpha\\beta}^{\\rm AH}(\\hbar\\omega)=\\frac{ie^2}{\\hbar\\Omega_c} \\sum_{n,m}(f_{m{\\bf k}}-f_{n{\\bf k}}) {\\rm Re}\\left[ \\frac{\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}}                     {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}                      -(\\hbar\\omega+i\\eta)} \\right] A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}).\\)\\) Finally the joint density of states is \\(\\(\\label{eq:jdos} \\rho_{cv}(\\hbar\\omega)=\\frac{1}{N_k}\\sum_{\\bf k}\\sum_{n,m} f_{n{\\bf k}}(1-f_{m{\\bf k}}) \\overline{\\delta}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-\\hbar\\omega).\\)\\)</p> <p>Equations\u00a0([eq:lorentzian]{reference-type=\"ref\" reference=\"eq:lorentzian\"}--[eq:jdos]{reference-type=\"ref\" reference=\"eq:jdos\"}) contain the parameter \\(\\eta\\), whose value can be chosen using the keyword\\ <code>[kubo_]smr_fixed_en_width</code>. Better results can often be achieved by adjusting the value of \\(\\eta\\) for each pair of states, i.e., \\(\\eta\\rightarrow \\eta_{nm\\bf k}\\). This is done as follows (see description of the keyword <code>adpt_smr_fac</code>) \\(\\(\\eta_{nm{\\bf k}}=\\alpha\\vert \\bm{\\nabla}_{\\bf k} (\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}})\\vert \\Delta k.\\)\\)</p> <p>The energy eigenvalues \\(\\varepsilon_{n\\bf k}\\), band velocities \\(\\bm{\\nabla}_{\\bf k}\\varepsilon_{n{\\bf k}}\\), and off-diagonal Berry connection \\({\\bf A}_{nm}({\\bf k})\\) entering the previous four equations are evaluated over a \\(k\\)-point grid by Wannier interpolation, as described in Refs.\u00a0<sup>3</sup><sup>4</sup>. After averaging over the Brillouin zone, the Hermitean and anti-Hermitean parts of the conductivity are assembled into the symmetric and antisymmetric tensors \\(\\(\\begin{aligned} \\sigma^{\\rm S}_{\\alpha\\beta}&amp;= {\\rm Re}\\sigma^{\\rm H}_{\\alpha\\beta}+i{\\rm Im}\\sigma^{\\rm AH}_{\\alpha\\beta}\\\\ \\sigma^{\\rm A}_{\\alpha\\beta}&amp;= {\\rm Re}\\sigma^{\\rm AH}_{\\alpha\\beta}+i{\\rm Im}\\sigma^{\\rm H}_{\\alpha\\beta}, \\end{aligned}\\)\\) whose independent components are written as a function of frequency onto nine separate files.</p>"},{"location":"user_guide/postw90/berry/#berry_taskahc-anomalous-hall-conductivity","title":"<code>berry_task=ahc</code>: anomalous Hall conductivity","text":"<p>The antisymmetric tensor \\(\\sigma^{\\rm A}_{\\alpha\\beta}\\) is odd under time reversal, and therefore vanishes in non-magnetic systems, while in ferromagnets with spin-orbit coupling it is generally nonzero. The imaginary part \\({\\rm Im}\\sigma^{\\rm H}_{\\alpha\\beta}\\) describes magnetic circular dichroism, and vanishes as \\(\\omega\\rightarrow 0\\). The real part \\({\\rm Re}\\sigma^{\\rm AH}_{\\alpha\\beta}\\) describes the anomalous Hall conductivity (AHC), and remains finite in the static limit.</p> <p>The intrinsic dc AHC is obtained by setting \\(\\eta=0\\) and \\(\\omega=0\\) in Eq.\u00a0([eq:sig-AH]{reference-type=\"ref\" reference=\"eq:sig-AH\"}). The contribution from point \\({\\bf k}\\) in the Brillouin zone is \\(\\(\\sigma^{\\rm AH}_{{\\bf k},\\alpha\\beta}(0)=\\frac{2e^2}{\\hbar\\Omega_c} \\sum_{n,m}f_{n\\bf k}(1-f_{m\\bf k}) {\\rm Im}\\langle \\nabla_{k_\\alpha} u_{n\\bf k}\\vert u_{m\\bf k}\\rangle \\langle u_{m\\bf k}\\vert\\nabla_{k_\\beta} u_{n\\bf k}\\rangle,\\)\\) where we replaced \\(f_{n\\bf k}-f_{m\\bf k}\\) with \\(f_{n\\bf k}(1-f_{m\\bf k})-f_{m\\bf k}(1-f_{n\\bf k})\\).</p> <p>This expression is not the most convenient for ab initio calculations, as the sums run over the complete set of occupied and empty states. In practice the sum over empty states can be truncated, but a relatively large number should be retained to obtain accurate results. Using the resolution of the identity \\(1=\\sum_m \\vert u_{m\\bf   k}\\rangle \\langle u_{m\\bf k}\\vert\\) and noting that the term \\(\\sum_{n,m}f_{n\\bf k}f_{m\\bf k}(\\ldots)\\) vanishes identically, we arrive at the celebrated formula for the intrinsic AHC in terms of the Berry curvature, \\(\\(\\begin{aligned} \\label{eq:ahc} \\sigma^{\\rm AH}_{\\alpha\\beta}(0)&amp;=\\frac{e^2}{\\hbar} \\frac{1}{N_k\\Omega_c}\\sum_{\\bf k}(-1)\\Omega_{\\alpha\\beta}({\\bf k}),\\\\ %\\sum_n (-1)f_{n\\bf k}\\Omega_{n,\\alpha\\beta}({\\bf k}). \\label{eq:curv-occ} \\Omega_{\\alpha\\beta}({\\bf k})&amp;=\\sum_n f_{n\\bf k}\\Omega_{n,\\alpha\\beta}({\\bf k}). \\end{aligned}\\)\\) Note that only occupied states enter this expression. Once we have a set of Wannier functions spanning the valence bands (together with a few low-lying conduction bands, typically) Eq.\u00a0([eq:ahc]) can be evaluated by Wannier interpolation as described in Refs.\u00a0<sup>3</sup><sup>5</sup>, with no truncation involved.</p>"},{"location":"user_guide/postw90/berry/#berry_taskmorb-orbital-magnetization","title":"<code>berry_task=morb</code>: orbital magnetization","text":"<p>The ground-state orbital magnetization of a crystal is given by\u00a0<sup>1</sup><sup>6</sup> \\(\\(\\begin{aligned} \\label{eq:morb} {\\bf M}^{\\rm orb}&amp;=\\frac{e}{\\hbar} %\\int_{\\rm BZ}\\frac{d{\\bf k}}{(2\\pi)^3} \\frac{1}{N_k\\Omega_c}\\sum_{\\bf k}{\\bf M}^{\\rm orb}({\\bf k}),\\\\ \\label{eq:morb-k} {\\bf M}^{\\rm orb}({\\bf k})&amp;= \\sum_n\\,\\frac{1}{2}f_{n{\\bf k}}\\, {\\rm Im}\\,\\langle \\bm{\\nabla}_{\\bf k}u_{n{\\bf k}}\\vert \\times \\left(H_{\\bf k}+\\varepsilon_{n{\\bf k}}-2\\varepsilon_F\\right) \\vert \\bm{\\nabla}_{\\bf k}u_{n{\\bf k}}\\rangle, \\end{aligned}\\)\\) where \\(\\varepsilon_F\\) is the Fermi energy. The Wannier-interpolation calculation is described in Ref.\u00a0<sup>5</sup>. Note that the definition of \\({\\bf M}^{\\rm orb}({\\bf k})\\) used here differs by a factor of \\(-1/2\\) from the one in Eq.\u00a0(97) and Fig.\u00a02 of that work.</p>"},{"location":"user_guide/postw90/berry/#sec:shc","title":"<code>berry_task=shc</code>: spin Hall conductivity","text":"<p>The Kubo-Greenwood formula for the intrinsic spin Hall conductivity (SHC) of a crystal in the independent-particle approximation reads <sup>7</sup><sup>8</sup><sup>9</sup> \\(\\(\\label{eq:kubo_shc} \\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega) =  \\frac{\\hbar}{\\Omega_c N_k} \\sum_{\\bm{k}}\\sum_{n} f_{n\\bm{k}} \\\\ \\sum_{m \\neq n} \\frac{2\\operatorname{Im}[\\langle n\\bm{k}| \\hat{j}_{\\alpha}^{\\gamma}|m\\bm{k}\\rangle     \\langle m\\bm{k}| -e\\hat{v}_{\\beta}|n\\bm{k}\\rangle]} {(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})^2-(\\hbar\\omega +i\\eta)^2}.\\)\\) The spin current operator \\(\\hat{j}_{\\alpha}^{\\gamma}= \\frac{1}{2}\\{\\hat{s}_{\\gamma},\\hat{v}_{\\alpha}\\}\\) where the spin operator \\(\\hat{s}_{\\gamma}=\\frac{\\hbar}{2}\\hat{\\sigma}_{\\gamma}\\). Indices \\(\\alpha,\\beta\\) denote Cartesian directions, \\(\\gamma\\) denotes the direction of spin, commonly \\(\\alpha = x, \\beta = y, \\gamma = z\\). \\(\\Omega_c\\) is the cell volume, \\(N_k\\) is the number of \\(k\\)-points used for sampling the Brillouin zone, and \\(f_{n{\\bf k}}=f(\\varepsilon_{n{\\bf k}})\\) is the Fermi-Dirac distribution function. \\(\\hbar\\omega\\) is the optical frequency, and \\(\\eta&gt;0\\) is an adjustable smearing parameter with unit of energy.</p> <p>The velocity matrix element in the numerator is the same as Eq.\u00a0([eq:velocity_mat]{reference-type=\"ref\" reference=\"eq:velocity_mat\"}), so the only unknown quantity is the spin current matrix \\(\\langle n\\bm{k}| \\hat{j}_{\\alpha}^{\\gamma}|m\\bm{k}\\rangle\\). We can use Wannier interpolation technique to efficiently calculate this matrix, and there are two derivation according to the degree of approximation. A noteworthy difference is the way in which two ab-initio matrix elements are evaluated, \\(\\(\\langle u_{n{\\bf k}}\\vert\\sigma_\\gamma H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\langle u_{n{\\bf k}}\\vert\\sigma_\\gamma \\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\gamma = x, y, z\\)\\) These are evaluated by <code>pw2wannier90</code> using Ryoo's method. In contrast, Qiao's method does not require <code>pw2wannier90</code>, but it assumes an approximation \\(1\\approx\\sum_{ l\\in ab-initio{\\rm \\,bands}}|u_{l\\bm{k}}\\rangle \\langle u_{l\\bm{k}}|\\). You can choose which method to evaluate this value with <code>shc_method</code> in the input file. For a full derivation please refer to Ref.\u00a0<sup>7</sup> or Ref.\u00a0<sup>8</sup>.</p> <p>The Eq.\u00a0([eq:kubo_shc]{reference-type=\"ref\" reference=\"eq:kubo_shc\"}) can be further separated into band-projected Berry curvature-like term \\(\\(\\label{eq:kubo_shc_berry} \\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}) = {\\hbar}^2 \\sum_{     m\\ne n}\\frac{-2\\operatorname{Im}[\\langle n\\bm{k}|      \\frac{1}{2}\\{\\hat{\\sigma}_{\\gamma},\\hat{v}_{\\alpha}\\}|m\\bm{k}\\rangle     \\langle m\\bm{k}| \\hat{v}_{\\beta}|n\\bm{k}\\rangle]} {(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})^2-(\\hbar\\omega+i\\eta)^2},\\)\\) \\(k\\)-resolved term which sums over occupied bands \\(\\(\\label{eq:kubo_shc_berry_sum} \\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}) = \\sum_{n} f_{n\\bm{k}} \\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}),\\)\\) and the SHC is \\(\\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega) =  -\\frac{e^2}{\\hbar}\\frac{1}{\\Omega_c N_k}\\sum_{\\bm{k}} \\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}).\\)\\) The unit of the \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k})\\) is \\(\\text{length}^{2}\\) (Angstrom\\(^2\\) or Bohr\\(^2\\), depending on your choice of <code>berry_curv_unit</code> in the input file), and the unit of \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\) is \\((\\hbar/e)\\)S/cm (the unit is written in the header of the output file). The case of \\(\\omega=0\\) corresponds to direct current (dc) SHC while that of \\(\\omega\\ne0\\) corresponds to alternating current (ac) SHC or frequency-dependent SHC. Note in some papers Eq.\u00a0([eq:kubo_shc_berry]{reference-type=\"ref\" reference=\"eq:kubo_shc_berry\"}) is called as spin Berry curvature. However, it was pointed out by Ref.\u00a0<sup>10</sup> that this name is misleading, so we use a somewhat awkward name \"Berry curvature-like term\" to refer to Eq.\u00a0([eq:kubo_shc_berry]{reference-type=\"ref\" reference=\"eq:kubo_shc_berry\"}). The \\(k\\)-resolved term Eq.\u00a0([eq:kubo_shc_berry_sum]{reference-type=\"ref\" reference=\"eq:kubo_shc_berry_sum\"}) can be used to draw <code>kslice</code> plot, and the band-projected Berry curvature-like term Eq.\u00a0([eq:kubo_shc_berry]{reference-type=\"ref\" reference=\"eq:kubo_shc_berry\"}) can be used to color the <code>kpath</code> plot.</p> <p>Same as the case of optical conductivity, the parameter \\(\\eta\\) contained in the Eq.\u00a0([eq:kubo_shc_berry]{reference-type=\"ref\" reference=\"eq:kubo_shc_berry\"}) can be chosen using the keyword <code>[kubo_]smr_fixed_en_width</code>. Also, adaptive smearing can be employed by the keyword <code>[kubo_]adpt_smr</code> (see Examples 29 and 30 in the Tutorial).</p> <p>Please cite the following paper\u00a0<sup>7</sup> or \u00a0<sup>8</sup> when publishing SHC results obtained using this method:</p> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao,\\ Calculation of intrinsic spin Hall conductivity by Wannier interpolation,\\ Phys. Rev. B. 98, 214402 (2018), DOI:10.1103/PhysRevB.98.214402.</p> <p>or</p> <p>Ji Hoon Ryoo, Cheol-hwan Park, and Ivo Souza,\\ Computation of intrinsic spin Hall conductivities from first principles using maximally localized Wannier functions,\\ Phys. Rev. B. 99, 235113 (2019), DOI:10.1103/PhysRevB.99.235113.</p>"},{"location":"user_guide/postw90/berry/#berry_tasksc-shift-current","title":"<code>berry_task=sc</code>: shift current","text":"<p>The shift-current contribution to the second-order response is characterized by a frequency-dependent third-rank tensor\u00a0<sup>11</sup> \\(\\(\\label{eq:shiftcurrent} \\begin{split} \\sigma^{abc}(0;\\omega,-\\omega)=&amp;-\\frac{i\\pi e^3}{4\\hbar^2 \\Omega_c N_k} \\sum_{\\bm{k}} \\sum_{n,m}(f_{n\\bm{k}}-f_{m\\bm{k}}) \\times \\left(r^b_{ mn}(\\bm{k})r^{c;a}_{nm}(\\bm{k}) + r^c_{mn}(\\bm{k})r^{b;a}_{ nm}(\\bm{k})\\right)\\\\ &amp;\\times \\left[\\delta(\\omega_{mn\\bm{k}}-\\omega)+\\delta(\\omega_{nm\\bm{k}}-\\omega)\\right], \\end{split}\\)\\) where \\(a,b,c\\) are spatial indexes and \\(\\omega_{mn\\bm{k}}=(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})/\\hbar\\). The expression in Eq.\u00a0[eq:shiftcurrent]{reference-type=\"ref\" reference=\"eq:shiftcurrent\"} involves the dipole matrix element \\(\\(\\label{eq:r} r^a_{ nm}(\\bm{k})=(1-\\delta_{nm})A^a_{ nm}(\\bm{k}),\\)\\) and its generalized derivative \\(\\(\\label{eq:gen-der} r^{a;b}_{nm}(\\bm{k})=\\partial_{k_{b}} r^a_{nm}(\\bm{k}) -i\\left(A^b_{nn}(\\bm{k})-A^b_{ mm}(\\bm{k})\\right)r^a_{ nm}(\\bm{k}).\\)\\) The first-principles evaluation of the above expression is technically challenging due to the presence of an extra \\(k\\)-space derivative. The implementation in <code>wannier90</code> follows the scheme proposed in Ref.\u00a0<sup>12</sup>, following the spirit of the Wannier-interpolation method for calculating the AHC\u00a0<sup>3</sup> by reformulating \\(k\\cdot p\\) perturbation theory within the subspace of wannierized bands. This strategy inherits the practical advantages of the sum-over-states approach, but without introducing the truncation errors usually associated with this procedure\u00a0<sup>11</sup>.</p> <p>As in the case of the optical conductivity, a broadened delta function can be applied in Eq.\u00a0[eq:shiftcurrent]{reference-type=\"ref\" reference=\"eq:shiftcurrent\"} by means of the parameter \\(\\eta\\) (see Eq.\u00a0[eq:lorentzian]{reference-type=\"ref\" reference=\"eq:lorentzian\"}) using the keyword <code>[kubo_]smr_fixed_en_width</code>, and adaptive smearing can be employed using the keyword <code>[kubo_]adpt_smr</code>.</p> <p>Please cite Ref.\u00a0<sup>12</sup> when publishing shift-current results using this method.</p>"},{"location":"user_guide/postw90/berry/#sec:kdotp","title":"<code>berry_task=kdotp</code>: \\(k\\cdot p\\) coefficients","text":"<p>Consider a Hamiltonian \\(\\(\\label{eq:H} H=H^{0}+H^{\\prime}\\)\\) where the eigenvalues \\(E_{n}\\) and eigenfunctions \\(\\vert n\\rangle\\) of \\(H^{0}\\) are known, and \\(H^{\\prime}\\) is a perturbation. In a nutshell, quasi-degenerate perturbation theory assumes that the set of eigenfunctions of \\(H^0\\) can be divided into subsets \\(A\\) and \\(B\\) that are weakly coupled by \\(H^{\\prime}\\), and that we are only interested in subset \\(A\\). This theory asserts that a transformed Hamiltonian \\(\\tilde{H}\\) exists within subspace \\(A\\) such that \\(\\(\\label{eq:pert-exp} \\tilde{H}=\\tilde{H}^{0}+\\tilde{H}^{1}+\\tilde{H}^{2} + \\cdots\\)\\) where \\(\\tilde{H}^{j}\\) contain matrix elements of \\(H^{\\prime}\\) to the \\(j\\)th power. According to Appendix B of Ref\u00a0<sup>13</sup>, the first three terms are \\(\\(\\begin{aligned} \\label{eq:pert-matelem0} &amp; \\tilde{H}^{0}_{mm'} = H^{0}_{mm'},\\\\ \\label{eq:pert-matelem1} &amp; \\tilde{H}^{1}_{mm'} = H^{'}_{mm'},\\\\ \\label{eq:pert-matelem2} &amp; \\tilde{H}^{2}_{mm'} = \\dfrac{1}{2}\\sum_{l}H^{'}_{ml}H^{'}_{lm'} \\left(  \\dfrac{1}{E_{m}-E_{l}}+\\dfrac{1}{E_{m'}-E_{l}} \\right), \\end{aligned}\\)\\) where \\(m,m'\\in A\\) and \\(l\\in B\\). The approximation \\(\\tilde{H}\\sim \\tilde{H}^{0}+\\tilde{H}^{1}\\) amounts to truncating \\(H\\) to the \\(A\\) subspace. By further including \\(\\tilde{H}^{2}\\), the coupling to the \\(B\\) subspace is incorporated approximately, \"renormalizing\" the elements of the truncated matrix.</p> <p>We adopt the notation described in Sec. III.B of Ref.\u00a0<sup>3</sup>. We shift the origin of \\(k\\) space to the point where the band edge (or some other band extremum of interest) is located, and Taylor expand around that point the Wannier-gauge Hamiltonian, \\(\\(\\label{eq:HW-exp} H^{(W)}(\\bm{k})=H^{(W)}(0) +\\sum_{a}H_{a}^{(W)}(0)k_{a} +\\dfrac{1}{2}\\sum_{ab}H_{ab}^{(W)}(0)k_{a}k_{b} + \\mathcal{O}(k^{3})\\)\\) where \\(a,b=x,y,z\\), and \\(\\(\\begin{aligned} &amp;H_{a}^{(W)}(0)=\\left. \\dfrac{\\partial H^{(W)}(\\bm{k})}{\\partial k_{a}}\\right\\rvert_{\\bm{k}=0}\\\\ &amp;H_{ab}^{(W)}(0)=\\left. \\dfrac{\\partial^{2} H^{(W)}(\\bm{k})}{\\partial k_{a}\\partial k_{b}}\\right\\rvert_{\\bm{k}=0} \\end{aligned}\\)\\)</p> <p>We now apply to \\(H^{(W)}(\\bm{k})\\) a similarity transformation \\(U(0)\\) that diagonalizes \\(H^{(W)}(0)\\), and call the transformed Hamiltonian \\(H(\\bm{k})\\), \\(\\(\\label{eq:Hbar} H(\\bm{k})=\\overbrace{\\overline{H}}^{H^{0}} + \\overbrace{\\sum_{a}\\overline{H}_{a}k_{a} +\\dfrac{1}{2}\\sum_{ab}\\overline{H}_{ab}k_{a}k_{b}}^{H^{\\prime}} + \\mathcal{O}(k^{3}),\\)\\) where we introduced the notation \\(\\(\\overline{\\mathcal{O}}=U^{\\dagger}(0)\\mathcal{O}^{(W)}(0)U(0),\\)\\) and applied it to \\(\\mathcal{O}=H,{H}_{a},{H}_{ab}\\). We can now apply quasi-degenerate perturbation theory by choosing the diagonal matrix \\(\\overline{H}\\) as our \\(H^{0}\\), and the remaining (nondiagonal) terms in Eq. [eq:Hbar] as \\(H^{\\prime}\\). Collecting terms in Eq.\u00a0([eq:pert-exp]{reference-type=\"ref\" reference=\"eq:pert-exp\"}) up to second order in \\(k\\) we get \\(\\(\\label{eq:Htilde}  \\tilde{H}_{mm'}(\\bm{k}) =  \\overline{H}_{mm'} + \\sum_{a} \\left(\\overline{H}_{a}\\right)_{mm'}k_{a}  + \\dfrac{1}{2}\\sum_{a,b}\\left[ \\left(\\overline{H}_{ab}\\right)_{mm'} + \\left({T}_{ab}\\right)_{mm'} \\right]k_{a}k_{b}+ \\mathcal{O}(k^{3}),\\)\\) where \\(m,m'\\in A\\) and we have defined the virtual-transition matrix \\(\\(\\label{eq:Tab} \\left({T}_{ab}\\right)_{mm'}=\\sum_{l\\in B} \\left(\\overline{H}_{a}\\right)_{ml}\\left(\\overline{H}_{b}\\right)_{lm'}   \\times \\left(  \\dfrac{1}{E_{m}-E_{l}}+\\dfrac{1}{E_{m'}-E_{l}} \\right) =  \\left({T}_{ab}\\right)_{m'm}^{*}.\\)\\) (The \\(T_{ab}\\) term in Eq. [eq:Htilde] gives an Hermitean contribution to \\(\\tilde{H}(\\bm{k})\\) only after summing over \\(a\\) and \\(b\\), whereas the other terms are Hermitean already before summing.)</p> <p>The implementation in <code>wannier90</code> follows the scheme proposed in Ref.\u00a0<sup>14</sup>, and outputs \\(\\overline{H}_{mm'}\\) in <code>seedname-kdotp_0.dat</code>, \\(\\left(\\overline{H}_{a}\\right)_{mm'}\\) in <code>seedname-kdotp_1.dat</code>, and \\(\\left[\\left(\\overline{H}_{ab}\\right)_{mm'} + \\left({T}_{ab}\\right)_{mm'}\\right]/2\\) in <code>seedname-kdotp_2.dat</code>.</p> <p>Please cite Ref.\u00a0<sup>14</sup> when publishing \\(k\\cdot p\\) results using this method.</p>"},{"location":"user_guide/postw90/berry/#needed-matrix-elements","title":"Needed matrix elements","text":"<p>All the quantities entering the formulas for the optical conductivity and AHC can be calculated by Wannier interpolation once the Hamiltonian and position matrix elements \\(\\langle {\\bf 0}n\\vert H\\vert {\\bf R}m\\rangle\\) and \\(\\langle {\\bf 0}n\\vert {\\bf r}\\vert {\\bf   R}m\\rangle\\) are known\u00a0<sup>3</sup><sup>4</sup>. Those matrix elements are readily available at the end of a standard MLWF calculation with <code>wannier90</code>. In particular, \\(\\langle {\\bf   0}n\\vert {\\bf r}\\vert {\\bf R}m\\rangle\\) can be calculated by Fourier transforming the overlap matrices in Eq.\u00a0(1.7), \\(\\(\\langle u_{n{\\bf k}}\\vert u_{m{\\bf k}+{\\bf b}}\\rangle.\\)\\) Further Wannier matrix elements are needed for the orbital magnetization\u00a0<sup>5</sup>. In order to calculate them using Fourier transforms, one more piece of information must be taken from the \\(k\\)-space ab-initio calculation, namely, the matrices \\(\\(\\langle u_{n{\\bf k}+{\\bf b}_1}\\vert H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle\\)\\) over the ab-initio \\(k\\)-point mesh\u00a0<sup>5</sup>. These are evaluated by <code>pw2wannier90</code>, the interface routine between <code>pwscf</code> and <code>wannier90</code>, by adding to the input file <code>seedname.pw2wan</code> the line \\(\\({\\tt %\\begin{quote} write\\_uHu = .true. %\\end{quote} }\\)\\) The calculation of spin Hall conductivity needs the spin matrix elements \\(\\(\\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma \\vert u_{m{\\bf k}}\\rangle,  \\gamma = x, y, z\\)\\) from the ab-initio \\(k\\)-point mesh. These are also evaluated by <code>pw2wannier90</code> by adding to the input file <code>seedname.pw2wan</code> the line \\(\\({\\tt     %\\begin{quote}     write\\_spn = .true.     %\\end{quote} }\\)\\) If one uses Ryoo's method to calculate spin Hall conductivity, the further matrix elements are needed: \\(\\(\\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma \\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\gamma = x, y, z\\)\\) and these are evaluated by adding to the input file <code>seedname.pw2wan</code> the lines \\(\\({\\tt     write\\_sHu = .true. }\\)\\) \\(\\({\\tt     write\\_sIu = .true. }\\)\\)</p> <ol> <li> <p>Di Xiao, Ming-Che Chang, and Qian Niu. Berry phase effects on electronic properties. Rev. Mod. Phys., 82:1959\u20132007, Jul 2010. doi:10.1103/RevModPhys.82.1959.\u00a0\u21a9\u21a9</p> </li> <li> <p>E. I. Blount. Solid State Physics, 13:305, 1962.\u00a0\u21a9</p> </li> <li> <p>X. Wang, J. R. Yates, I. Souza, and D. Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, 74:195118, 2006.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>J. R. Yates, X. Wang, D. Vanderbilt, and I. Souza. Spectral and fermi surface properties from wannier interpolation. Phys. Rev. B, 75:195121, 2007.\u00a0\u21a9\u21a9</p> </li> <li> <p>M. G. Lopez, D. Vanderbilt, T. Thonhauser, and I. Souza. Phys. Rev. B, 85:014435, 2012.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>D. Ceresoli, T. Thonhauser, D. Vanderbilt, and R. Resta. Orbital magnetization in crystalline solids: multi-band insulators, chern insulators, and metals. Phys. Rev. B, 74:024408, 2006.\u00a0\u21a9</p> </li> <li> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao. Calculation of intrinsic spin hall conductivity by wannier interpolation. Phys. Rev. B, 98:214402, Dec 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.98.214402, doi:10.1103/PhysRevB.98.214402.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Ji Hoon Ryoo, Cheol-Hwan Park, and Ivo Souza. Computation of intrinsic spin hall conductivities from first principles using maximally localized wannier functions. Phys. Rev. B, 99:235113, Jun 2019. URL: https://link.aps.org/doi/10.1103/PhysRevB.99.235113, doi:10.1103/PhysRevB.99.235113.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>G. Y. Guo, S. Murakami, T.-W. Chen, and N. Nagaosa. Intrinsic spin hall effect in platinum: first-principles calculations. Phys. Rev. Lett., 100:096401, Mar 2008. URL: https://link.aps.org/doi/10.1103/PhysRevLett.100.096401, doi:10.1103/PhysRevLett.100.096401.\u00a0\u21a9</p> </li> <li> <p>M Gradhand, D V Fedorov, F Pientka, P Zahn, I Mertig, and B L Gy\u00f6rffy. First-principle calculations of the berry curvature of bloch states for charge and spin transport of electrons. Journal of Physics: Condensed Matter, 24(21):213202, may 2012. URL: https://doi.org/10.1088%2F0953-8984%2F24%2F21%2F213202, doi:10.1088/0953-8984/24/21/213202.\u00a0\u21a9</p> </li> <li> <p>J. E. Sipe and A. I. Shkrebtii. Second-order optical response in semiconductors. Phys. Rev. B, 61:5337, 2000. doi:10.1103/PhysRevB.61.5337.\u00a0\u21a9\u21a9</p> </li> <li> <p>Julen Iba\u00f1ez-Azpiroz, Stepan S. Tsirkin, and Ivo Souza. Ab initio calculation of the shift photocurrent by wannier interpolation. Phys. Rev. B, 97:245143, Jun 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.97.245143, doi:10.1103/PhysRevB.97.245143.\u00a0\u21a9\u21a9</p> </li> <li> <p>R. Winkler. Spin-orbit Coupling Effects in Two-Dimensional Electron and Hole Systems. Springer, 2003 edition edition, 2003. ISBN 978-3-540-01187-3.\u00a0\u21a9</p> </li> <li> <p>Julen Iba\u00f1ez-Azpiroz, Fernando de Juan, and Ivo Souza. Quantitative analysis of two-band \\(k\\cdot p\\) models describing the shift-current photoconductivity. ArXiv e-prints, 2019. URL: http://arxiv.org/abs/1910.06172, arXiv:1910.06172.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/postw90/boltzwann/","title":"Electronic transport calculations with the <code>BoltzWann</code>\u00a0module","text":"<p>By setting \\(\\verb#boltzwann#=\\verb#TRUE#\\), <code>postw90</code>\u00a0will call the <code>BoltzWann</code>\u00a0routines to calculate some transport coefficients using the Boltzmann transport equation in the relaxation time approximation.</p> <p>In particular, the transport coefficients that are calculated are: the electrical conductivity \\(\\bm{\\mathrm{\\sigma}}\\), the Seebeck coefficient \\(\\bm{\\mathrm{S}}\\) and the coefficient \\(\\bm{\\mathrm{K}}\\) (defined below; it is the main ingredient of the thermal conductivity).</p> <p>The list of parameters of the <code>BoltzWann</code>\u00a0module are summarized in Table\u00a0[parameter_keywords_bw]{reference-type=\"ref\" reference=\"parameter_keywords_bw\"}. An example of a Boltzmann transport calculation can be found in the <code>wannier90</code>\u00a0Tutorial.</p> <p>Note: By default, the code assumes to be working with a 3D bulk material, with periodicity along all three spatial directions. If you are interested in studying 2D systems, set the correct value for the <code>boltz_2d_dir</code> variable (see Sec.\u00a0[sec:boltz2ddir]{reference-type=\"ref\" reference=\"sec:boltz2ddir\"} for the documentation). This is important for the evaluation of the Seebeck coefficient.</p> <p>Please cite the following paper\u00a0<sup>1</sup> when publishing results obtained using the <code>BoltzWann</code>\u00a0module:</p> <p>G. Pizzi, D. Volja, B. Kozinsky, M. Fornari, and N. Marzari,\\ BoltzWann: A code for the evaluation of thermoelectric and electronic transport properties with a maximally-localized Wannier functions basis,\\ Comp. Phys. Comm. 185, 422 (2014), DOI:10.1016/j.cpc.2013.09.015.</p>"},{"location":"user_guide/postw90/boltzwann/#sec:boltzwann-theory","title":"Theory","text":"<p>The theory of the electronic transport using the Boltzmann transport equations can be found for instance in Refs.\u00a0<sup>2</sup><sup>3</sup><sup>4</sup>. Here we briefly summarize only the main results.</p> <p>The current density \\(\\bm{\\mathrm{J}}\\) and the heat current (or energy flux density) \\(\\bm{\\mathrm{J}}_Q\\) can be written, respectively, as \\(\\(\\begin{aligned}   \\bm{\\mathrm{J}}   &amp;= \\bm{\\mathrm{\\sigma}}(\\bm{\\mathrm{E}} - \\bm{\\mathrm{S}} \\bm{\\mathrm{\\nabla }}T) \\\\   \\bm{\\mathrm{J}}_Q &amp;= T \\bm{\\mathrm{\\sigma }}\\bm{\\mathrm{S}} \\bm{\\mathrm{E}} - \\bm{\\mathrm{K}} \\bm{\\mathrm{\\nabla }}T, \\end{aligned}\\)\\) where the electrical conductivity \\(\\bm{\\mathrm{\\sigma}}\\), the Seebeck coefficient \\(\\bm{\\mathrm{S}}\\) and \\(\\bm{\\mathrm{K}}\\) are \\(3\\times 3\\) tensors, in general.</p> <p>Note: the thermal conductivity \\(\\bm{\\mathrm{\\kappa}}\\) (actually, the electronic part of the thermal conductivity), which is defined as the heat current per unit of temperature gradient in open-circuit experiments (i.e., with \\(\\bm{\\mathrm{J}}=0\\)) is not precisely \\(\\bm{\\mathrm{K}}\\), but \\(\\bm{\\mathrm{\\kappa }}= \\bm{\\mathrm{K}}-\\bm{\\mathrm{S}} \\bm{\\mathrm{\\sigma }}\\bm{\\mathrm{S}} T\\) (see for instance Eq.\u00a0(7.89) of Ref.\u00a0<sup>2</sup> or Eq.\u00a0(XI-57b) of Ref.\u00a0<sup>3</sup>). The thermal conductivity \\(\\bm{\\mathrm{\\kappa}}\\) can be then calculated from the \\(\\bm{\\mathrm{\\sigma}}\\), \\(\\bm{\\mathrm{S}}\\) and \\(\\bm{\\mathrm{K}}\\) tensors output by the code.</p> <p>These quantities depend on the value of the chemical potential \\(\\mu\\) and on the temperature \\(T\\), and can be calculated as follows: \\(\\(\\begin{aligned} _{ij}(\\mu,T)&amp;=e^2 \\int_{-\\infty}^{+\\infty} d\\varepsilon \\left(-\\frac {\\partial f(\\varepsilon,\\mu,T)}{\\partial \\varepsilon}\\right)\\Sigma_{ij}(\\varepsilon), \\\\   [\\bm{\\mathrm{\\sigma }}\\bm{\\mathrm{S}}]_{ij}(\\mu,T)&amp;=\\frac e T \\int_{-\\infty}^{+\\infty} d\\varepsilon \\left(-\\frac {\\partial f(\\varepsilon,\\mu,T)}{\\partial \\varepsilon}\\right)(\\varepsilon-\\mu)\\Sigma_{ij}(\\varepsilon), \\label{eq:boltz-sigmas}\\\\   [\\bm{\\mathrm{K}}]_{ij}(\\mu,T)&amp;=\\frac 1 T \\int_{-\\infty}^{+\\infty} d\\varepsilon \\left(-\\frac {\\partial f(\\varepsilon,\\mu,T)}{\\partial \\varepsilon}\\right)(\\varepsilon-\\mu)^2 \\Sigma_{ij}(\\varepsilon),\\label{eq:boltz-thermcond} \\end{aligned}\\)\\) where \\([\\bm{\\mathrm{\\sigma }}\\bm{\\mathrm{S}}]\\) denotes the product of the two tensors \\(\\bm{\\mathrm{\\sigma}}\\) and \\(\\bm{\\mathrm{S}}\\), \\(f(\\varepsilon,\\mu,T)\\) is the usual Fermi--Dirac distribution function \\(\\(f(\\varepsilon,\\mu,T) = \\frac{1}{e^{(\\varepsilon-\\mu)/K_B T}+1}\\)\\) and \\(\\Sigma_{ij}(\\varepsilon)\\) is the Transport Distribution Function (TDF) tensor, defined as \\(\\(\\Sigma_{ij}(\\varepsilon) = \\frac 1 V \\sum_{n,\\bm{\\mathrm{k}}} v_i(n,\\bm{\\mathrm{k}}) v_j(n,\\bm{\\mathrm{k}}) \\tau(n,\\bm{\\mathrm{k}}) \\delta(\\varepsilon - E_{n,k}).\\)\\)</p> <p>In the above formula, the sum is over all bands \\(n\\) and all states \\(\\bm{\\mathrm{k}}\\) (including spin, even if the spin index is not explicitly written here). \\(E_{n,\\bm{\\mathrm{k}}}\\) is the energy of the \\(n-\\)th band at \\(\\bm{\\mathrm{k}}\\), \\(v_i(n,\\bm{\\mathrm{k}})\\) is the \\(i-\\)th component of the band velocity at \\((n,\\bm{\\mathrm{k}})\\), \\(\\delta\\) is the Dirac's delta function, \\(V = N_k \\Omega_c\\) is the total volume of the system (\\(N_k\\) and \\(\\Omega_c\\) being the number of \\(k\\)-points used to sample the Brillouin zone and the unit cell volume, respectively), and finally \\(\\tau\\) is the relaxation time. In the relaxation-time approximation adopted here, \\(\\tau\\) is assumed as a constant, i.e., it is independent of \\(n\\) and \\(\\bm{\\mathrm{k}}\\) and its value (in fs) is read from the input variable <code>boltz_relax_time</code>.</p>"},{"location":"user_guide/postw90/boltzwann/#files","title":"Files","text":""},{"location":"user_guide/postw90/boltzwann/#seedname_boltzdosdat","title":"<code>seedname_boltzdos.dat</code>","text":"<p>OUTPUT. Written by <code>postw90</code>\u00a0if <code>boltz_calc_also_dos</code> is <code>true</code>. Note that even if there are other general routines in <code>postw90</code>\u00a0which specifically calculate the DOS, it may be convenient to use the routines in <code>BoltzWann</code>\u00a0setting <code>boltz_calc_also_dos = true</code> if one must also calculate the transport coefficients. In this way, the (time-demanding) band interpolation on the \\(k\\) mesh is performed only once, resulting in a much shorter execution time.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each energy \\(\\varepsilon\\) on the grid, containing a number of columns. The first column is the energy \\(\\varepsilon\\). The following is the DOS at the given energy \\(\\varepsilon\\). The DOS can either be calculated using the adaptive smearing scheme (see the following note) if <code>boltz_dos_adpt_smr</code> is <code>true</code>, or using a \"standard\" fixed smearing, whose type and value are defined by <code>boltz_dos_smr_type</code> and <code>boltz_dos_smr_fixed_en_width</code>, respectively. If spin decomposition is required (input flag <code>spin_decomp</code>), further columns are printed, with the spin-up projection of the DOS, followed by spin-down projection.</p> <p>Note</p> <p>Note that in <code>BoltzWann</code>\u00a0the adaptive (energy) smearing scheme also implements a simple adaptive \\(k-\\)mesh scheme: if at any given \\(k\\) point one of the band gradients is zero, then that \\(k\\) point is replaced by 8 neighboring \\(k\\) points. Thus, the final results for the DOS may be slightly different with respect to that given by the <code>dos</code> module.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_tdfdat","title":"<code>seedname_tdf.dat</code>","text":"<p>OUTPUT. This file contains the Transport Distribution Function (TDF) tensor \\(\\bm{\\mathrm{\\Sigma}}\\) on a grid of energies.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each energy \\(\\varepsilon\\) on the grid, containing a number of columns. The first is the energy \\(\\varepsilon\\), the followings are the components if \\(\\bm{\\mathrm{\\Sigma}}(\\varepsilon)\\) in the following order: \\(\\Sigma_{xx}\\), \\(\\Sigma_{xy}\\), \\(\\Sigma_{yy}\\), \\(\\Sigma_{xz}\\), \\(\\Sigma_{yz}\\), \\(\\Sigma_{zz}\\). If spin decomposition is required (input flag <code>spin_decomp</code>), 12 further columns are provided, with the 6 components of \\(\\bm{\\mathrm{\\Sigma}}\\) for the spin up, followed by those for the spin down.</p> <p>The energy \\(\\varepsilon\\) is in eV, while \\(\\bm{\\mathrm{\\Sigma}}\\) is in \\(\\displaystyle\\frac{1}{\\hbar^2}\\cdot\\frac{\\mathrm{eV}\\cdot\\mathrm{fs}}{\\text{\\AA}}\\).</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_elconddat","title":"<code>seedname_elcond.dat</code>","text":"<p>OUTPUT. This file contains the electrical conductivity tensor \\(\\bm{\\mathrm{\\sigma}}\\) on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(\\sigma_{xx}\\), \\(\\sigma_{xy}\\), \\(\\sigma_{yy}\\), \\(\\sigma_{xz}\\), \\(\\sigma_{yz}\\), \\(\\sigma_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the electrical conductivity tensor ar in SI units, i.e. in 1/\\(\\Omega\\)/m.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_sigmasdat","title":"<code>seedname_sigmas.dat</code>","text":"<p>OUTPUT. This file contains the tensor \\(\\bm{\\mathrm{\\sigma}}\\bm{\\mathrm{S}}\\), i.e. the product of the electrical conductivity tensor and of the Seebeck coefficient as defined by Eq.\u00a0[eq:boltz-sigmas]{reference-type=\"eqref\" reference=\"eq:boltz-sigmas\"}, on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\((\\sigma S)_{xx}\\), \\((\\sigma S)_{xy}\\), \\((\\sigma S)_{yy}\\), \\((\\sigma S)_{xz}\\), \\((\\sigma S)_{yz}\\), \\((\\sigma S)_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the tensor ar in SI units, i.e. in A/m/K.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_seebeckdat","title":"<code>seedname_seebeck.dat</code>","text":"<p>OUTPUT. This file contains the Seebeck tensor \\(\\bm{\\mathrm{S}}\\) on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>Note that in the code the Seebeck coefficient is defined as zero when the determinant of the electrical conductivity \\(\\bm{\\mathrm{\\sigma}}\\) is zero. If there is at least one \\((\\mu, T)\\) pair for which \\(\\det \\bm{\\mathrm{\\sigma}}=0\\), a warning is issued on the output file.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 11 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(S_{xx}\\), \\(S_{xy}\\), \\(S_{xz}\\), \\(S_{yx}\\), \\(S_{yy}\\), \\(S_{yz}\\), \\(S_{zx}\\), \\(S_{zy}\\), \\(S_{zz}\\).</p> <p>NOTE: therefore, the format of the columns of this file is different from the other three files (elcond, sigmas and kappa)!</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the Seebeck tensor ar in SI units, i.e. in V/K.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_kappadat","title":"<code>seedname_kappa.dat</code>","text":"<p>OUTPUT. This file contains the tensor \\(\\bm{\\mathrm{K}}\\) defined in Sec.\u00a03.1{reference-type=\"ref\" reference=\"sec:boltzwann-theory\"} on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(K_{xx}\\), \\(K_{xy}\\), \\(K_{yy}\\), \\(K_{xz}\\), \\(K_{yz}\\), \\(K_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the \\(\\bm{\\mathrm{K}}\\) tensor are the SI units for the thermal conductivity, i.e. in W/m/K.</p> <ol> <li> <p>G. Pizzi, D. Volja, B. Kozinsky, M. Fornari, and N. Marzari. Boltzwann: a code for the evaluation of thermoelectric and electronic transport properties with a maximally-localized wannier functions basis. Comput. Phys. Commun., 185:422, 2014. doi:doi:10.1016/j.cpc.2013.09.015.\u00a0\u21a9</p> </li> <li> <p>J. Ziman. Principles of the Theory of Solids. Cambridge University Press, 2<sup>nd</sup> ed. edition, 1972.\u00a0\u21a9\u21a9</p> </li> <li> <p>G. Grosso and G. P. Parravicini. Solid State Physics. Academic Press, 2000.\u00a0\u21a9\u21a9</p> </li> <li> <p>G. D. Mahan. Transport properties. In Intern. Tables for Crystallography, volume D, chapter 1.8, pages 7828. 2006.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/postw90/geninterp/","title":"Generic Band interpolation","text":"<p>By setting \\(\\verb#geninterp#=\\verb#TRUE#\\), <code>postw90</code>\u00a0will calculate the band energies (and possibly the band derivatives, if also <code>geninterp_alsofirstder</code> is set to <code>TRUE</code>) on a generic list of \\(k\\) points provided by the user.</p> <p>The list of parameters of the Generic Band Interpolation module are summarized in Table\u00a0[parameter_keywords_geninterp]{reference-type=\"ref\" reference=\"parameter_keywords_geninterp\"}. The list of input \\(k\\) points for which the band have to be calculated is read from the file named <code>seedname_geninterp.kpt</code>. The format of this file is described below.</p>"},{"location":"user_guide/postw90/geninterp/#files","title":"Files","text":""},{"location":"user_guide/postw90/geninterp/#seedname_geninterpkpt","title":"<code>seedname_geninterp.kpt</code>","text":"<p>INPUT. Read by <code>postw90</code>\u00a0if <code>geninterp</code> is <code>true</code>.</p> <p>The first line is a comment (its maximum allowed length is 500 characters).</p> <p>The second line must contain <code>crystal</code> (or <code>frac</code>) if the \\(k\\)-point coordinates are given in crystallographic units, i.e., in fractional units with respect to the primitive reciprocal lattice vectors. Otherwise, it must contain <code>cart</code> (or <code>abs</code>) if instead the \\(k-\\)point coordinates are given in absolute coordinates (in units of 1/\u00c5) along the \\(k_x\\), \\(k_y\\) and \\(k_z\\) axes.</p> <p>Note on units: In the case of absolute coordinates, if \\(a_{lat}\\) is the lattice constant expressed in angstrom, and you want to represent for instance the point \\(X=\\frac {2\\pi}{a_{lat}} [0.5, 0, 0]\\), then you have to input for its \\(x\\) coordinate \\(k_x = 0.5 * 2 * \\pi / a_{lat}\\). As a practical example, if \\(a_{lat}=4\\)\u00c5, then \\(k_x = 0.78539816339745\\) in absolute coordinates in units of 1/\u00c5.</p> <p>The third line must contain the number \\(n\\) of following \\(k\\) points.</p> <p>The following \\(n\\) lines must contain the list of \\(k\\) points in the format</p> <pre><code>kpointidx k1 k2 k3\n</code></pre> <p>where <code>kpointidx</code> is an integer identifying the given \\(k\\) point, and <code>k1</code>, <code>k2</code> and <code>k3</code> are the three coordinates of the \\(k\\) points in the chosen units.</p>"},{"location":"user_guide/postw90/geninterp/#sec:seedname.geninterp.dat","title":"<code>seedname_geninterp.dat</code> or <code>seedname_geninterp_NNNNN.dat</code>","text":"<p>OUTPUT. This file/these files contain the interpolated band energies (and also the band velocities if the input flag <code>geninterp_alsofirstder</code> is <code>true</code>).</p> <p>If the flag <code>geninterp_single_file</code> is <code>true</code>, then a single file <code>seedname_geninterp.dat</code> is written by the code at the end of the calculation. If instead one sets <code>geninterp_single_file</code> to <code>false</code>, each process writes its own output file, named <code>seedname_geninterp_00000.dat</code>, <code>seedname_geninterp_00001.dat</code>, ...</p> <p>This flag is useful when one wants to parallelize the calculation on many nodes, and it should be used especially for systems with a small number of Wannier functions, when one wants to compute the bands on a large number of \\(k\\) points (if the flag <code>geninterp_single_file</code> is <code>true</code>, instead, all the I/O is made by the root node, which is a significant bottleneck).</p> <p>Important! The files are not deleted before the start of a calculation, but only the relevant files are overwritten. Therefore, if one first performs a calculation and then a second one with a smaller number of processors, care is needed to avoid to mix the results of the older calculations with those of the new one. In case of doubt, either check the date stamp in the first line of the <code>seedname_geninterp_*.dat</code> files, or simply delete the <code>seedname_geninterp_*.dat</code> files before starting the new calculation.</p> <p>To join the files, on can simply use the following command:</p> <pre><code>cat seedname_geninterp_*.dat &gt; seedname_geninterp.dat\n</code></pre> <p>or, if one wants to remove the comment lines:</p> <pre><code>rm seedname_geninterp.dat\nfor i in seedname_geninterp_*.dat ; do grep -v \\# \"$i\" &gt;&gt; \\\nseedname_geninterp.dat ; done\n</code></pre> <p>The first few lines of each files are comments (starting with #), containing a datestamp, the comment line as it is read from the input file, and a header. The following lines contain the band energies (and derivatives) for each band and \\(k\\) point (the energy index runs faster than the \\(k\\)-point index). For each of these lines, the first four columns contain the \\(k\\)-point index as provided in the input, and the \\(k\\) coordinates (always in absolute coordinates, in units of 1/\u00c5). The fifth column contains the band energy.</p> <p>If <code>geninterp_alsofirstder</code> is <code>true</code>, three further columns are printed, containing the three first derivatives of the bands along the \\(k_x\\), \\(k_y\\) and \\(k_z\\) directions (in units of eV\\(\\cdot\\)\u00c5).</p> <p>The \\(k\\) point coordinates are in units of 1/\u00c5, the band energy is in eV.</p>"},{"location":"user_guide/postw90/gyrotropic/","title":"Overview of the <code>gyrotropic</code> module []{#ch:gyrotropic label=\"ch:gyrotropic\"}","text":"<p>The <code>gyrotropic</code> module of <code>postw90</code> is called by setting <code>gyrotropic = true</code> and choosing one or more of the available options for <code>gyrotropic_task</code>. The module computes the quantities, studied in <sup>1</sup>, where more details may be found.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-d0-the-berry-curvature-dipole","title":"<code>gyrotropic_task=-d0</code>: the Berry curvature dipole","text":"<p>The traceless dimensionless tensor \\(\\(\\label{eq:D_ab} D_{ab}=\\int[d{\\bm k}]\\sum_n \\frac{\\partial E_n}{\\partial{k_a}} \\Omega_n^b \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n},\\)\\)</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-dw-the-finite-frequency-generalization-of-the-berry-curvature-dipole","title":"<code>gyrotropic_task=-dw</code>: the finite-frequency generalization of the Berry curvature dipole","text":"\\[\\label{eq:D-tilde} \\widetilde{D}_{ab}(\\omega)=\\int[d{\\bm k}]\\sum_n \\frac{\\partial E_n}{\\partial{k_a}}\\widetilde\\Omega^b_n(\\omega) \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n},\\] <p>where \\(\\widetilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)\\) is a finite-frequency generalization of the Berry curvature: \\(\\(\\label{eq:curv-w} \\widetilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)=- \\sum_m\\,\\frac{\\omega^2_{{\\bm k}mn}}{\\omega^2_{{\\bm k}mn}-\\omega^2} {\\rm Im}\\left({\\bm A}_{{\\bm k}nm}\\times{\\bm A}_{{\\bm k}mn}\\right)\\)\\) Contrary to the Berry curvature, the divergence of \\(\\tilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)\\) is generally nonzero. As a result, \\(\\widetilde{D}(\\omega)\\) can have a nonzero trace at finite frequencies, \\(\\tilde{D}_\\|\\neq-2\\tilde{D}_\\perp\\) in Te.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-c-the-ohmic-conductivity","title":"<code>gyrotropic_task=-C</code>: the ohmic conductivity","text":"<p>In the constant relaxation-time approximation the ohmic conductivity is expressed as \\(\\sigma_{ab}=(2\\pi e\\tau/\\hbar)C_{ab}\\), with \\(\\(\\label{eq:C_ab} C_{ab}=\\frac{e}{h}\\int[d{\\bm k}]\\sum_n\\, \\frac{\\partial E_n}{\\partial{k_a}} \\frac{\\partial E_n}{\\partial{k_b}} \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n}\\)\\) a positive quantity with units of surface current density (A/cm).</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-k-the-kinetic-magnetoelectric-effect-kme","title":"<code>gyrotropic_task=-K</code>: the kinetic magnetoelectric effect (kME)","text":"<p>A microscopic theory of the intrinsic kME effect in bulk crystals was recently developed\u00a0<sup>2</sup><sup>3</sup>.</p> <p>The response is described by \\(\\(\\label{eq:K_ab} K_{ab}=\\int[d{\\bm k}]\\sum_n\\frac{\\partial E_n}{\\partial{k_a}} m_n^b  \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n},\\)\\) which has the same form as Eq.\u00a0([eq:D_ab]{reference-type=\"ref\" reference=\"eq:D_ab\"}), but with the Berry curvature replaced by the intrinsic magnetic moment \\({\\bm m}_{{\\bm k}n}\\) of the Bloch electrons, which has the spin and orbital components given by\u00a0<sup>4</sup> \\(\\(\\begin{aligned} \\label{eq:m-spin} m^{\\rm spin}_{{\\bm k}n}&amp;=&amp;-\\frac{1}{2}g_s\\mu_{\\rm B} \\langle\\psi_{{\\bm k}       n}\\vert\\bf \\sigma\\vert\\psi_{{\\bm k}n}\\rangle\\\\ \\label{eq:m-orb} {\\bm m}^{\\rm orb}_{{\\bm k}n}&amp;=&amp;\\frac{e}{2\\hbar}{\\rm Im} \\langle{\\bm\\partial}_{\\bm k}u_{{\\bm k}n}\\vert\\times (H_{\\bm k}-E_{{\\bm k}n})\\vert{\\bm\\partial}_{\\bm k}u_{{\\bm k}n}\\rangle, \\end{aligned}\\)\\) where \\(g_s\\approx 2\\) and we chose \\(e&gt;0\\).</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-dos-the-density-of-states","title":"<code>gyrotropic_task=-dos</code>: the density of states","text":"<p>The density of states is calculated with the same width and type of smearing, as the other properties of the <code>gyrotropic</code> module</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-noa-the-interband-contributionto-the-natural-optical-activity","title":"<code>gyrotropic_task=-noa</code>: the interband contributionto the natural optical activity","text":"<p>Natural optical rotatory power is given by <sup>5</sup> \\(\\(\\label{eq:rho-c} \\rho_0(\\omega)=\\frac{\\omega^2}{2c^2}{\\rm Re}\\,\\gamma_{xyz}(\\omega).\\)\\) for light propagating ling the main symmetry axis of a crystal \\(z\\). Here \\(\\gamma_{xyz}(\\omega)\\) is an anti-symmetric (in \\(xy\\)) tensor with units of length, which has both inter- and intraband contributions.</p> <p>Following Ref.\u00a0<sup>6</sup> for the interband contribution we writewe write, with \\(\\partial_c\\equiv\\partial/\\partial k_c\\), \\(\\(\\begin{gathered} {\\rm Re}\\,\\gamma_{abc}^{\\mathrm{inter}}(\\omega)=\\frac{e^2}{\\varepsilon_0\\hbar^2} \\int[d{\\bm k}] \\sum_{n,l}^{o,e}\\, \\Bigl[ \\frac{1}{\\omega_{ln}^2-\\omega^2}  {\\rm Re}\\left(A_{ln}^bB_{nl}^{ac}-A_{ln}^aB_{nl}^{bc}\\right) \\\\ -\\frac{3\\omega_{ln}^2-\\omega^2}{(\\omega_{ln}^2-\\omega^2)^2}  \\partial_c(E_l+E_n){\\rm Im}\\left(A_{nl}^aA_{ln}^b\\right)    \\Bigr]. \\label{eq:gamma-inter} \\end{gathered}\\)\\) The summations over \\(n\\) and \\(l\\) span the occupied (\\(o\\)) and empty (\\(e\\)) bands respectively, \\(\\omega_{ln}=(E_l-E_n)/\\hbar\\), and \\({\\bm A}_{ln}({\\bm k})\\) is given by ([eq:berry-connection-matrix]{reference-type=\"ref\" reference=\"eq:berry-connection-matrix\"}) Finally, the matrix \\(B_{nl}^{ac}\\) has both orbital and spin contributions given by \\(\\(\\label{eq:B-ac-orb} B_{nl}^{ac\\,({\\rm orb})}=   \\langle u_n\\vert(\\partial_aH)\\vert\\partial_c u_l\\rangle  -\\langle\\partial_c u_n\\vert(\\partial_aH)\\vert u_l\\rangle\\)\\) and \\(\\(\\label{eq:B-ac-spin} B_{nl}^{ac\\,({\\rm spin})}=-\\frac{i\\hbar^2}{m_e}\\epsilon_{abc} \\langle u_n\\vert\\sigma_b\\vert u_l\\rangle.\\)\\) The spin matrix elements contribute less than 0.5% of the total \\(\\rho_0^{\\rm inter}\\) of Te. Expanding \\(H=\\sum_m \\vert u_m\\rangle E_m \\langle u_m\\vert\\) we obtain for the orbital matrix elements \\(\\(B_{nl}^{ac\\,({\\rm orb})}=-i\\partial_a(E_n+E_l)A_{nl}^c \\sum_m \\Bigl\\{ (E_n-E_m) A_{nm}^aA_{ml}^c -(E_l-E_m) A_{nm}^cA_{ml}^a \\Bigr\\}. \\label{eq:Bnl-sum}\\)\\) This reduces the calculation of \\(B^{\\text{(orb)}}\\) to the evaluation of band gradients and off-diagonal elements of the Berry connection matrix. Both operations can be carried out efficiently in a Wannier-function basis following Ref.\u00a0<sup>7</sup>.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-spin-compute-also-the-spin-component-of-noa-and-kme","title":"<code>gyrotropic_task=-spin</code>: compute also the spin component of NOA and KME","text":"<p>Unless this task is specified, only the orbital contributions are calcuated in NOA and KME, thus contributions from Eqs.\u00a0([eq:m-spin]{reference-type=\"ref\" reference=\"eq:m-spin\"}) and\u00a0([eq:B-ac-spin]{reference-type=\"ref\" reference=\"eq:B-ac-spin\"}) are omitted.</p> <ol> <li> <p>S. S. Tsirkin, P. Aguado Puente, and I. Souza. Gyrotropic effects in trigonal tellurium studied from first principles. ArXiv e-prints, October 2017. arXiv:1710.03204.\u00a0\u21a9</p> </li> <li> <p>T. Yoda, T. Yokoyama, and S. Murakami. Current-induced orbital and spin magnetizations in crystals with helical structure. Sci. Rep., 5:12024, 2015. URL: http://dx.doi.org/10.1038/srep12024, doi:10.1038/srep12024.\u00a0\u21a9</p> </li> <li> <p>S. Zhong, J. E. Moore, and I. Souza. Gyrotropic magnetic effect and the magnetic moment on the fermi surface. Phys. Rev. Lett., 116:077201, Feb 2016. URL: https://link.aps.org/doi/10.1103/PhysRevLett.116.077201, doi:10.1103/PhysRevLett.116.077201.\u00a0\u21a9</p> </li> <li> <p>Di Xiao, Ming-Che Chang, and Qian Niu. Berry phase effects on electronic properties. Rev. Mod. Phys., 82:1959\u20132007, Jul 2010. doi:10.1103/RevModPhys.82.1959.\u00a0\u21a9</p> </li> <li> <p>E.L. Ivchenko and G.E. Pikus. Natural optical activity of semiconductors (tellurium). Sov. Phys. Solid State, 16(7):1261, 1975. URL: https://www.scopus.com/inward/record.uri?eid=2-s2.0-0016444392&amp;partnerID=40&amp;md5=d44204b27eb4356a166f389a0f8c8a4e.\u00a0\u21a9</p> </li> <li> <p>A. Malashevich and I. Souza. Band theory of spatial dispersion in magnetoelectrics. Phys. Rev. B, 82:245118, 2010. doi:10.1103/PhysRevB.82.245118.\u00a0\u21a9</p> </li> <li> <p>J. R. Yates, X. Wang, D. Vanderbilt, and I. Souza. Spectral and fermi surface properties from wannier interpolation. Phys. Rev. B, 75:195121, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/code_overview/","title":"Code Overview","text":"<p><code>wannier90</code>\u00a0can operate in two modes:</p> <ol> <li> <p>Post-processing mode: read in the overlaps and projections from     file as computed inside a first-principles code. We expect this to     be the most common route to using <code>wannier90</code>, and is described in     Ch.\u00a05;</p> </li> <li> <p>Library mode: as a set of library routines to be called from     within a first-principles code that passes the overlaps and     projections to the <code>wannier90</code>\u00a0library routines and in return gets     the unitary transformation corresponding to MLWF. This route should     be used if the MLWF are needed within the first-principles code, for     example in post-LDA methods such as LDA+U or SIC, and is described     in Ch.\u00a06{reference-type=\"ref\"     reference=\"ch:wann-lib\"}.</p> </li> </ol> Schematic overview of the module structure of <code>wannier90</code>. Modules may only use data and subroutines from lower modules."},{"location":"user_guide/wannier90/files/","title":"Files","text":""},{"location":"user_guide/wannier90/files/#seednamewin","title":"<code>seedname.win</code>","text":"<p>INPUT. The master input file; contains the specification of the system and any parameters for the run. For a description of input parameters, see Chapter\u00a02{reference-type=\"ref\" reference=\"chap:parameters\"}; for examples, see Section\u00a010.1 and the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/files/#units","title":"Units","text":"<p>The following are the dimensional quantities that are specified in the master input file:</p> <ul> <li> <p>Direct lattice vectors</p> </li> <li> <p>Positions (of atomic or projection) centres in real space</p> </li> <li> <p>Energy windows</p> </li> <li> <p>Positions of k-points in reciprocal space</p> </li> <li> <p>Convergence thresholds for the minimisation of \\(\\Omega\\)</p> </li> <li> <p><code>zona</code> (see Section\u00a03.1{reference-type=\"ref\"     reference=\"sec:proj\"})</p> </li> <li> <p><code>wannier_plot_cube</code>: cut-off radius for plotting WF in Gaussian cube     format</p> </li> </ul> <p>Notes:</p> <ul> <li> <p>The units (either <code>ang</code> (default) or <code>bohr</code>) in which the lattice     vectors, atomic positions or projection centres are given can be set     in the first line of the blocks <code>unit_cell_cart</code>, <code>atoms_cart</code> and     <code>projections</code>, respectively, in <code>seedname.win</code>.</p> </li> <li> <p>Energy is always in eV.</p> </li> <li> <p>Convergence thresholds are always in \u00c5\\(^{2}\\)</p> </li> <li> <p>Positions of k-points are always in crystallographic coordinates     relative to the reciprocal lattice vectors.</p> </li> <li> <p><code>zona</code> is always in reciprocal Angstrom (\u00c5\\(^{-1}\\))</p> </li> <li> <p>The keyword <code>length_unit</code> may be set to <code>ang</code> (default) or <code>bohr</code>,     in order to set the units in which the quantities in the output file     <code>seedname.wout</code> are written.</p> </li> <li> <p><code>wannier_plot_radius</code> is in Angstrom</p> </li> </ul> <p>The reciprocal lattice vectors \\(\\{\\mathbf{B}_{1},\\mathbf{B}_{2},\\mathbf{B}_{3}\\}\\) are defined in terms of the direct lattice vectors \\(\\{\\mathbf{A}_{1},\\mathbf{A}_{2},\\mathbf{A}_{3}\\}\\) by the equation</p> \\[\\mathbf{B}_{1} = \\frac{2\\pi}{\\Omega}\\mathbf{A}_{2}\\times\\mathbf{A}_{3} \\ \\ \\ \\mathrm{etc.},\\] <p>where the cell volume is \\(V=\\mathbf{A}_{1}\\cdot(\\mathbf{A}_{2}\\times\\mathbf{A}_{3})\\).</p>"},{"location":"user_guide/wannier90/files/#seednamemmn","title":"<code>seedname.mmn</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a05 for details.</p>"},{"location":"user_guide/wannier90/files/#seednameamn","title":"<code>seedname.amn</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a05 for details.</p>"},{"location":"user_guide/wannier90/files/#seednamedmn","title":"<code>seedname.dmn</code>","text":"<p>INPUT. Read if <code>site_symmetry = .true.</code> (symmetry-adapted mode). Written by the underlying electronic structure code. See Chapter\u00a05 for details.</p>"},{"location":"user_guide/wannier90/files/#seednameeig","title":"<code>seedname.eig</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a05 for details.</p>"},{"location":"user_guide/wannier90/files/#sec:old-nnkp","title":"<code>seedname.nnkp</code>","text":"<p>OUTPUT. Written by <code>wannier90</code>\u00a0when <code>postproc_setup=.TRUE.</code> (or, alternatively, when <code>wannier90</code>\u00a0is run with the <code>-pp</code> command-line option). See Chapter\u00a05{reference-type=\"ref\" reference=\"ch:wann-pp\"} for details.</p>"},{"location":"user_guide/wannier90/files/#seednamewout","title":"<code>seedname.wout</code>","text":"<p>OUTPUT. The master output file. Here we give a description of the main features of the output. The verbosity of the output is controlled by the input parameter <code>iprint</code>. The higher the value, the more detail is given in the output file. The default value is 1, which prints minimal information.</p>"},{"location":"user_guide/wannier90/files/#header","title":"Header","text":"<p>The header provides some basic information about <code>wannier90</code>, the authors, the code version and release, and the execution time of the current run. The header looks like the following different (the string might slightly change across different versions):</p> <pre><code>             +---------------------------------------------------+\n             |                                                   |\n             |                   WANNIER90                       |\n             |                                                   |\n             +---------------------------------------------------+\n             |                                                   |\n             |        Welcome to the Maximally-Localized         |\n             |        Generalized Wannier Functions code         |\n             |            http://www.wannier.org                 |\n             |                                                   |\n             |  Wannier90 Developer Group:                       |\n             |    Giovanni Pizzi    (EPFL)                       |\n             |    Valerio Vitale    (Cambridge)                  |\n             |    David Vanderbilt  (Rutgers University)         |\n             |    Nicola Marzari    (EPFL)                       |\n             |    Ivo Souza         (Universidad del Pais Vasco) |\n             |    Arash A. Mostofi  (Imperial College London)    |\n             |    Jonathan R. Yates (University of Oxford)       |\n             |                                                   |\n             |  For the full list of Wannier90 3.x authors,      |\n             |  please check the code documentation and the      |\n             |  README on the GitHub page of the code            |\n             |                                                   |\n             |                                                   |\n             |  Please cite                                      |\n                                       .\n                                       .\n             |                                                   |\n             +---------------------------------------------------+\n             |    Execution started on 18Dec2018 at 18:39:42     |\n             +---------------------------------------------------+\n</code></pre>"},{"location":"user_guide/wannier90/files/#system-information","title":"System information","text":"<p>This part of the output file presents information that <code>wannier90</code>\u00a0has read or inferred from the master input file <code>seedname.win</code>. This includes real and reciprocal lattice vectors, atomic positions, k-points, parameters for job control, disentanglement, localisation and plotting.</p> <pre><code>                                    ------\n                                    SYSTEM\n                                    ------\n\n                              Lattice Vectors (Ang)\n                    a_1     3.938486   0.000000   0.000000\n                    a_2     0.000000   3.938486   0.000000\n                    a_3     0.000000   0.000000   3.938486\n\n                   Unit Cell Volume:      61.09251  (Ang^3)\n\n                        Reciprocal-Space Vectors (Ang^-1)\n                    b_1     1.595330   0.000000   0.000000\n                    b_2     0.000000   1.595330   0.000000\n                    b_3     0.000000   0.000000   1.595330\n\n *----------------------------------------------------------------------------*\n |   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |\n +----------------------------------------------------------------------------+\n | Ba   1   0.00000   0.00000   0.00000   |    0.00000   0.00000   0.00000    |\n | Ti   1   0.50000   0.50000   0.50000   |    1.96924   1.96924   1.96924    |\n                                          .\n                                          . \n *----------------------------------------------------------------------------*\n\n                                ------------\n                                K-POINT GRID\n                                ------------\n\n             Grid size =  4 x  4 x  4      Total points =   64\n\n *---------------------------------- MAIN ------------------------------------*\n |  Number of Wannier Functions               :                 9             |\n |  Number of input Bloch states              :                 9             |\n |  Output verbosity (1=low, 5=high)          :                 1             |\n |  Length Unit                               :               Ang             |\n |  Post-processing setup (write *.nnkp)      :                 F             |\n                                              .\n                                              .\n *----------------------------------------------------------------------------*\n</code></pre>"},{"location":"user_guide/wannier90/files/#nearest-neighbour-k-points","title":"Nearest-neighbour k-points","text":"<p>This part of the output files provides information on the \\(\\mathrm{b}\\)-vectors and weights chosen to satisfy the condition of Eq.\u00a0[eq:B1].</p> <pre><code> *---------------------------------- K-MESH ----------------------------------*\n +----------------------------------------------------------------------------+\n |                    Distance to Nearest-Neighbour Shells                    |\n |                    ------------------------------------                    |\n |          Shell             Distance (Ang^-1)          Multiplicity         |\n |          -----             -----------------          ------------         |\n |             1                   0.398833                      6            |\n |             2                   0.564034                     12            |\n                                       .\n                                       .\n +----------------------------------------------------------------------------+\n | The b-vectors are chosen automatically                                     |\n | The following shells are used:   1                                         |\n +----------------------------------------------------------------------------+\n |                        Shell   # Nearest-Neighbours                        |\n |                        -----   --------------------                        |\n |                          1               6                                 |\n +----------------------------------------------------------------------------+\n | Completeness relation is fully satisfied [Eq. (B1), PRB 56, 12847 (1997)]  |\n +----------------------------------------------------------------------------+\n</code></pre>"},{"location":"user_guide/wannier90/files/#disentanglement","title":"Disentanglement","text":"<p>Then (if required) comes the part where \\(\\Omega_{\\mathrm{I}}\\) is minimised to disentangle the optimally-connected subspace of states for the localisation procedure in the next step.</p> <p>First, a summary of the energy windows that are being used is given:</p> <pre><code> *------------------------------- DISENTANGLE --------------------------------*\n +----------------------------------------------------------------------------+\n |                              Energy  Windows                               |\n |                              ---------------                               |\n |                   Outer:    2.81739  to   38.00000  (eV)                   |\n |                   Inner:    2.81739  to   13.00000  (eV)                   |\n +----------------------------------------------------------------------------+\n</code></pre> <p>Then, each step of the iterative minimisation of \\(\\Omega_{\\mathrm{I}}\\) is reported.</p> <pre><code>                   Extraction of optimally-connected subspace                  \n                   ------------------------------------------                  \n +---------------------------------------------------------------------+&lt;-- DIS\n |  Iter     Omega_I(i-1)      Omega_I(i)      Delta (frac.)    Time   |&lt;-- DIS\n +---------------------------------------------------------------------+&lt;-- DIS\n       1       3.82493590       3.66268867       4.430E-02      0.36    &lt;-- DIS\n       2       3.66268867       3.66268867       6.911E-15      0.37    &lt;-- DIS\n                                       .\n                                       .\n\n             &lt;&lt;&lt;      Delta &lt; 1.000E-10  over  3 iterations     &gt;&gt;&gt;\n             &lt;&lt;&lt; Disentanglement convergence criteria satisfied &gt;&gt;&gt;\n\n        Final Omega_I     3.66268867 (Ang^2)\n\n +----------------------------------------------------------------------------+\n</code></pre> <p>The first column gives the iteration number. For a description of the minimisation procedure and expressions for \\(\\Omega_{\\mathrm{I}}^{(i)}\\), see the original paper\u00a0<sup>1</sup>. The procedure is considered to be converged when the fractional difference between \\(\\Omega_{\\mathrm{I}}^{(i)}\\) and \\(\\Omega_{\\mathrm{I}}^{(i-1)}\\) is less than <code>dis_conv_tol</code> over <code>dis_conv_window</code> iterations. The final column gives a running account of the wall time (in seconds) so far. Note that at the end of each line of output, there are the characters \"<code>&lt;\u2013 DIS</code>\". This enables fast searching of the output using, for example, the Unix command <code>grep</code>:</p> <p><code>my_shell&gt; grep DIS wannier.wout | less</code></p>"},{"location":"user_guide/wannier90/files/#sec:files-wannierisation","title":"Wannierisation","text":"<p>The next part of the output file provides information on the minimisation of \\(\\widetilde{\\Omega}\\). At each iteration, the centre and spread of each WF is reported.</p> <pre><code>*------------------------------- WANNIERISE ---------------------------------*\n +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n\n ------------------------------------------------------------------------------\n Initial State\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52435832\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16120620\n                                      .\n                                      .\n      0     0.126E+02     0.0000000000       12.6297685260       0.29  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1491718 O_TOT=     12.6297685 &lt;-- SPRD\n ------------------------------------------------------------------------------\n Cycle:      1\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52414024\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16059775\n                                      .\n                                      .\n  Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62663472\n\n      1    -0.313E-02     0.0697660962       12.6266347170       0.34  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1460380 O_TOT=     12.6266347 &lt;-- SPRD\n Delta: O_D= -0.4530841E-18 O_OD= -0.3133809E-02 O_TOT= -0.3133809E-02 &lt;-- DLTA\n ------------------------------------------------------------------------------\n Cycle:      2\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52414866\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16052405\n                                      .\n                                      .\n   Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62646411\n\n      2    -0.171E-03     0.0188848262       12.6264641055       0.38  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1458674 O_TOT=     12.6264641 &lt;-- SPRD\n Delta: O_D= -0.2847260E-18 O_OD= -0.1706115E-03 O_TOT= -0.1706115E-03 &lt;-- DLTA\n ------------------------------------------------------------------------------\n                                      .\n                                      .\n ------------------------------------------------------------------------------\n Final State\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52416618\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16048545\n                                      .\n                                      .\n  Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62645344\n\n         Spreads (Ang^2)       Omega I      =    12.480596753\n        ================       Omega D      =     0.000000000\n                               Omega OD     =     0.145856689\n    Final Spread (Ang^2)       Omega Total  =    12.626453441\n ------------------------------------------------------------------------------\n</code></pre> <p>It looks quite complicated, but things look more simple if one uses <code>grep</code>:</p> <p><code>my_shell&gt; grep CONV wannier.wout</code></p> <p>gives</p> <pre><code> +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n      0     0.126E+02     0.0000000000       12.6297685260       0.29  &lt;-- CONV\n      1    -0.313E-02     0.0697660962       12.6266347170       0.34  &lt;-- CONV\n                                                   .\n                                                   .\n     50     0.000E+00     0.0000000694       12.6264534413       2.14  &lt;-- CONV\n</code></pre> <p>The first column is the iteration number, the second is the change in \\(\\Omega\\) from the previous iteration, the third is the root-mean-squared gradient of \\(\\Omega\\) with respect to variations in the unitary matrices \\(\\mathbf{U}^{(\\mathbf{k})}\\), and the last is the time taken (in seconds). Depending on the input parameters used, the procedure either runs for <code>num_iter</code> iterations, or a convergence criterion is applied on \\(\\Omega\\). See Section\u00a02.8{reference-type=\"ref\" reference=\"sec:wann_params\"} for details.</p> <p>Similarly, the command</p> <p><code>my_shell&gt; grep SPRD wannier.wout</code></p> <p>gives</p> <pre><code>        O_D=      0.0000000 O_OD=      0.1491718 O_TOT=     12.6297685 &lt;-- SPRD\n        O_D=      0.0000000 O_OD=      0.1460380 O_TOT=     12.6266347 &lt;-- SPRD\n                                            .\n                                            .\n        O_D=      0.0000000 O_OD=      0.1458567 O_TOT=     12.6264534 &lt;-- SPRD\n</code></pre> <p>which, for each iteration, reports the value of the diagonal and off-diagonal parts of the non-gauge-invariant spread, as well as the total spread, respectively. Recall from Section\u00a01 that \\(\\Omega = \\Omega_{\\mathrm{I}}+ \\Omega_{\\mathrm{D}} + \\Omega_{\\mathrm{OD}}\\).</p>"},{"location":"user_guide/wannier90/files/#wannierisation-with-selective-localization-and-constrained-centres","title":"Wannierisation with selective localization and constrained centres","text":"<p>For full details of the selectively localised Wannier function (SLWF) method, the reader is referred to Ref.\u00a0<sup>2</sup>. When using the SLWF method, only a few things change in the output file and in general the same principles described above will apply. In particular, when minimising the spread with respect to the degrees of freedom of only a subset of functions, it is not possible to cast the total spread functional \\(\\Omega\\) as a sum of a gauge-invariant part and a gauge-dependent part. Instead, one has \\(\\Omega^{'} = \\Omega_{\\mathrm{IOD}} + \\Omega_{\\mathrm{D}}\\), where \\(\\(\\Omega^{'} = \\sum_{n=1}^{J'&lt;J} \\left[\\langle r^2 \\rangle_n - \\overline{\\mathbf{r}}_{n}^{2}\\right]\\)\\) and \\(\\(\\Omega_{\\mathrm{IOD}} = \\sum_{n=1}^{J'&lt;J} \\left[\\langle r^2_n \\rangle- \\sum_{\\mathbf{R}} \\vert\\langle\\mathbf{R}n\\vert \\mathbf{r} \\vert n\\mathbf{R}\\rangle\\vert^2 \\right].\\)\\) The total number of Wannier functions is \\(J\\), whereas \\(J'\\) is the number functions to be selectively localized (so-called objective WFs). The information on the number of functions which are going to be selectively localized (<code>Number of Objective Wannier Functions</code>) is given in the <code>MAIN</code> section of the output file:</p> <pre><code> *---------------------------------- MAIN ------------------------------------*\n |  Number of Wannier Functions               :                 4             |\n |  Number of Objective Wannier Functions     :                 1             |\n |  Number of input Bloch states              :                 4             |\n</code></pre> <p>Whether or not the selective localization procedure has been switched on is reported in the <code>WANNIERISE</code> section as</p> <pre><code> |  Perform selective localization            :                 T             |\n</code></pre> <p>The next part of the output file provides information on the minimisation of the modified spread functional:</p> <pre><code> *------------------------------- WANNIERISE ---------------------------------*\n +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n\n ------------------------------------------------------------------------------\n Initial State\n  WF centre and spread    1  ( -0.857524,  0.857524,  0.857524 )     1.80463310\n  WF centre and spread    2  (  0.857524, -0.857524,  0.857524 )     1.80463311\n  WF centre and spread    3  (  0.857524,  0.857524, -0.857524 )     1.80463311\n  WF centre and spread    4  ( -0.857524, -0.857524, -0.857524 )     1.80463311\n  Sum of centres and spreads ( -0.000000, -0.000000,  0.000000 )     7.21853243\n\n      0    -0.317E+01     0.0000000000       -3.1653368719       0.00  &lt;-- CONV\n       O_D=      0.0000000 O_IOD=     -3.1653369 O_TOT=     -3.1653369 &lt;-- SPRD\n ------------------------------------------------------------------------------\n Cycle:      1\n  WF centre and spread    1  ( -0.853260,  0.853260,  0.853260 )     1.70201498\n  WF centre and spread    2  (  0.857352, -0.857352,  0.862454 )     1.84658331\n  WF centre and spread    3  (  0.857352,  0.862454, -0.857352 )     1.84658331\n  WF centre and spread    4  ( -0.862454, -0.857352, -0.857352 )     1.84658331\n  Sum of centres and spreads ( -0.001010,  0.001010,  0.001010 )     7.24176492\n\n      1    -0.884E-01     0.2093698260       -3.2536918930       0.00  &lt;-- CONV\n       O_IOD=     -3.2536919 O_D=      0.0000000 O_TOT=     -3.2536919 &lt;-- SPRD\nDelta: O_IOD= -0.1245020E+00 O_D=  0.0000000E+00 O_TOT= -0.8835502E-01 &lt;-- DLTA\n ------------------------------------------------------------------------------\n                                      .\n                                      .\n ------------------------------------------------------------------------------\n Final State\n  WF centre and spread    1  ( -0.890189,  0.890189,  0.890189 )     1.42375495\n  WF centre and spread    2  (  0.895973, -0.895973,  0.917426 )     2.14313664\n  WF centre and spread    3  (  0.895973,  0.917426, -0.895973 )     2.14313664\n  WF centre and spread    4  ( -0.917426, -0.895973, -0.895973 )     2.14313664\n  Sum of centres and spreads ( -0.015669,  0.015669,  0.015669 )     7.85316486\n\n         Spreads (Ang^2)       Omega IOD    =     1.423371553\n        ================       Omega D      =     0.000383395\n                               Omega Rest   =     9.276919811\n    Final Spread (Ang^2)       Omega Total  =     1.423754947\n ------------------------------------------------------------------------------\n</code></pre> <p>When comparing the output from an SLWF calculation with a standard wannierisation (see Sec.\u00a08.7.5{reference-type=\"ref\" reference=\"sec:files-wannierisation\"}), the only differences are in the definition of the spread functional. Hence, during the minimization <code>O_OD</code> is replaced by <code>O_IOD</code> and <code>O_TOT</code> now reflects the fact that the new total spread functional is \\(\\Omega^{'}\\). The part on the final state has one more item of information: the value of the difference between the global spread functional and the new spread functional given by <code>Omega Rest</code> \\(\\(\\Omega_{R} = \\sum_{n=1}^{J-J'} \\left[\\langle r^2 \\rangle_n - \\overline{\\mathbf{r}}_{n}^{2} \\right]\\)\\)</p> <p>If adding centre-constraints to the SLWFs, you will find the information about the centres of the original projections and the desired centres in the <code>SYSTEM</code> section</p> <pre><code> *----------------------------------------------------------------------------*\n | Wannier#        Original Centres              Constrained centres          |\n +----------------------------------------------------------------------------+\n |    1     0.25000   0.25000   0.25000   |    0.00000   0.00000   0.00000    |\n *----------------------------------------------------------------------------*\n</code></pre> <p>As before one can check that the selective localization with constraints is being used by looking at the <code>WANNIERISE</code> section:</p> <pre><code> |  Perform selective localization            :                 T             |\n |  Use constrains in selective localization  :                 T             |\n |  Value of the Lagrange multiplier          :         0.100E+01             |\n *----------------------------------------------------------------------------*\n</code></pre> <p>which also gives the selected value for the Lagrange multiplier. The output file for the minimisation section is modified as follows: both <code>O_IOD</code> and <code>O_TOT</code> now take into account the factors coming from the new term in the functional due to the constraints, which are implemented by adding the following penalty functional to the spread functional, \\(\\(\\lambda_c \\sum_{n=1}^{J'} \\left(\\overline{\\mathbf{r}}_n - \\mathbf{r}_{0n} \\right)^2,\\)\\) where \\(\\mathbf{r}_{0n}\\) is the desired centre for the \\(n^{\\text{th}}\\) Wannier function, see Ref.\u00a0<sup>2</sup> for details. The layout of the output file at each iteration is unchanged.</p> <pre><code>      1    -0.884E-01     0.2093698260       -3.2536918930       0.00  &lt;-- CONV\n</code></pre> <p>As regarding the final state, the only addition is the information on the value of the penalty functional associated with the constraints (<code>Penalty func</code>), which should be zero if the final centres of the Wannier functions are at the target centres:</p> <pre><code> Final State\n  WF centre and spread    1  ( -1.412902,  1.412902,  1.412902 )     1.63408756\n  WF centre and spread    2  (  1.239678, -1.239678,  1.074012 )     2.74801593\n  WF centre and spread    3  (  1.239678,  1.074012, -1.239678 )     2.74801592\n  WF centre and spread    4  ( -1.074012, -1.239678, -1.239678 )     2.74801592\n  Sum of centres and spreads ( -0.007559,  0.007559,  0.007559 )     9.87813534\n\n         Spreads (Ang^2)       Omega IOD_C   =    -4.261222001\n        ================       Omega D       =     0.000000000\n                               Omega Rest    =     5.616913337\n                               Penalty func  =     0.000000000\n    Final Spread (Ang^2)       Omega Total_C =    -4.261222001\n ------------------------------------------------------------------------------\n</code></pre>"},{"location":"user_guide/wannier90/files/#plotting","title":"Plotting","text":"<p>After WF have been localised, <code>wannier90</code>\u00a0enters its plotting routines (if required). For example, if you have specified an interpolated bandstucture:</p> <pre><code> *---------------------------------------------------------------------------*\n |                               PLOTTING                                    |\n *---------------------------------------------------------------------------*\n\n Calculating interpolated band-structure\n</code></pre>"},{"location":"user_guide/wannier90/files/#summary-timings","title":"Summary timings","text":"<p>At the very end of the run, a summary of the time taken for various parts of the calculation is given. The level of detail is controlled by the <code>timing_level</code> input parameter (set to 1 by default).</p> <pre><code> *===========================================================================*\n |                             TIMING INFORMATION                            |\n *===========================================================================*\n |    Tag                                                Ncalls      Time (s)|\n |---------------------------------------------------------------------------|\n |kmesh: get                                        :         1         0.212|\n |overlap: read                                     :         1         0.060|\n |wann: main                                        :         1         1.860|\n |plot: main                                        :         1         0.168|\n *---------------------------------------------------------------------------*\n\n All done: wannier90 exiting\n</code></pre>"},{"location":"user_guide/wannier90/files/#seednamechk","title":"<code>seedname.chk</code>","text":"<p>INPUT/OUTPUT. Information required to restart the calculation or enter the plotting phase. If we have used disentanglement this file also contains the rectangular matrices \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\).</p>"},{"location":"user_guide/wannier90/files/#seednamer2mn","title":"<code>seedname.r2mn</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_r2mn#=\\verb#true#\\). The matrix elements \\(\\langle m|r^2|n\\rangle\\) (where \\(m\\) and \\(n\\) refer to MLWF)</p>"},{"location":"user_guide/wannier90/files/#seedname_banddat","title":"<code>seedname_band.dat</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code>; The raw data for the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandgnu","title":"<code>seedname_band.gnu</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code> and <code>bands_plot_format=gnuplot</code>; A <code>gnuplot</code> script to plot the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandagr","title":"<code>seedname_band.agr</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code> and <code>bands_plot_format=xmgrace</code>; A <code>grace</code> file to plot the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandkpt","title":"<code>seedname_band.kpt</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code>; The k-points used for the interpolated band structure, in units of the reciprocal lattice vectors. This file can be used to generate a comparison band structure from a first-principles code.</p>"},{"location":"user_guide/wannier90/files/#seednamebxsf","title":"<code>seedname.bxsf</code>","text":"<p>OUTPUT. Written if <code>fermi_surface_plot=.TRUE.</code>; A Fermi surface plot file suitable for plotting with XCrySDen.</p>"},{"location":"user_guide/wannier90/files/#seedname_wxsf","title":"<code>seedname_w.xsf</code>","text":"<p>OUTPUT. Written if <code>wannier_plot=.TRUE.</code> and <code>wannier_plot_format=xcrysden</code>. Contains the <code>w</code>\\(^{\\mathrm{th}}\\) WF in real space in a format suitable for plotting with XCrySDen or VMD, for example.</p>"},{"location":"user_guide/wannier90/files/#seedname_wcube","title":"<code>seedname_w.cube</code>","text":"<p>OUTPUT. Written if <code>wannier_plot=.TRUE.</code> and <code>wannier_plot_format=cube</code>. Contains the <code>w</code>\\(^{\\mathrm{th}}\\) WF in real space in Gaussian cube format, suitable for plotting in XCrySDen, VMD, gopenmol etc.</p>"},{"location":"user_guide/wannier90/files/#unkps","title":"<code>UNKp.s</code>","text":"<p>INPUT. Read if <code>wannier_plot</code>=<code>.TRUE.</code> and used to plot the MLWF. Read if <code>transport_mode</code>=<code>lcr</code> and <code>tran_read_ht</code>=<code>.FALSE.</code> for use in automated lcr transport calculations.</p> <p>The periodic part of the Bloch states represented on a regular real space grid, indexed by k-point <code>p</code> (from 1 to <code>num_kpts</code>) and spin <code>s</code> ('1' for 'up', '2' for 'down').</p> <p>The name of the wavefunction file is assumed to have the form:</p> <pre><code>    write(wfnname,200) p,spin\n200 format ('UNK',i5.5,'.',i1)\n</code></pre> <p>The first line of each file should contain 5 integers: the number of grid points in each direction (<code>ngx</code>, <code>ngy</code> and <code>ngz</code>), the k-point number <code>ik</code> and the total number of bands <code>num_band</code> in the file. The full file will be read by <code>wannier90</code>\u00a0as:</p> <pre><code>read(file_unit) ngx,ngy,ngz,ik,nbnd  \ndo loop_b=1,num_bands\n  read(file_unit) (r_wvfn(nx,loop_b),nx=1,ngx*ngy*ngz)\nend do\n</code></pre> <p>If <code>spinors</code>=<code>true</code> then <code>s</code>='NC', and the name of the wavefunction file is assumed to have the form:</p> <pre><code>    write(wfnname,200) p\n200 format ('UNK',i5.5,'.NC')\n</code></pre> <p>and the file will be read by <code>wannier90</code>\u00a0as:</p> <pre><code>read(file_unit) ngx,ngy,ngz,ik,nbnd  \ndo loop_b=1,num_bands\n   read(file_unit) (r_wvfn_nc(nx,loop_b,1),nx=1,ngx*ngy*ngz) ! up-spinor\n   read(file_unit) (r_wvfn_nc(nx,loop_b,2),nx=1,ngx*ngy*ngz) ! down-spinor\nend do\n</code></pre> <p>All UNK files can be in formatted or unformatted style, this is controlled by the logical keyword <code>wvfn_formatted</code>.</p>"},{"location":"user_guide/wannier90/files/#seedname_centresxyz","title":"<code>seedname_centres.xyz</code>","text":"<p>OUTPUT. Written if <code>write_xyz=.TRUE.</code>; xyz format atomic structure file suitable for viewing with your favourite visualiser (<code>jmol</code>, <code>gopenmol</code>, <code>vmd</code>, etc.).</p>"},{"location":"user_guide/wannier90/files/#seedname_hrdat","title":"<code>seedname_hr.dat</code>","text":"<p>OUTPUT. Written if <code>write_hr=.TRUE.</code>. The first line gives the date and time at which the file was created. The second line states the number of Wannier functions <code>num_wann</code>. The third line gives the number of Wigner-Seitz grid-points <code>nrpts</code>. The next block of <code>nrpts</code> integers gives the degeneracy of each Wigner-Seitz grid point, with 15 entries per line. Finally, the remaining <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the Hamiltonian matrix element \\(H_{mn}^{(\\mathbf{R})}\\) in the WF basis, e.g.,</p> <pre><code> Created on 24May2007 at 23:32:09                            \n        20\n        17\n    4   1   2    1    4    1    1    2    1    4    6    1    1   1   2\n    1   2\n    0   0  -2    1    1   -0.001013    0.000000\n    0   0  -2    2    1    0.000270    0.000000\n    0   0  -2    3    1   -0.000055    0.000000\n    0   0  -2    4    1    0.000093    0.000000\n    0   0  -2    5    1   -0.000055    0.000000\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_rdat","title":"<code>seedname_r.dat</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_rmn#=\\verb#true#\\). The matrix elements \\(\\langle m\\mathbf{0}|\\mathbf{r}|n\\mathbf{R}\\rangle\\) (where \\(n\\mathbf{R}\\) refers to MLWF \\(n\\) in unit cell \\(\\mathbf{R}\\)). The first line gives the date and time at which the file was created. The second line states the number of Wannier functions <code>num_wann</code>. The third line states the number of \\(\\mathbf{R}\\) vectors <code>nrpts</code>. Similar to the case of the Hamiltonian matrix above, the remaining <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the position matrix element in the WF basis.</p>"},{"location":"user_guide/wannier90/files/#seedname_tbdat","title":"<code>seedname_tb.dat</code>","text":"<p>OUTPUT. Written if <code>write_tb=.TRUE.</code>. This file is essentially a combination of <code>seedname_hr.dat</code> and <code>seedname_r.dat</code>, plus lattice vectors. The first line gives the date and time at which the file was created. The second to fourth lines are the lattice vectors in Angstrom unit.</p> <pre><code> written on 27Jan2020 at 18:08:42 \n  -1.8050234585004898        0.0000000000000000        1.8050234585004898     \n   0.0000000000000000        1.8050234585004898        1.8050234585004898     \n  -1.8050234585004898        1.8050234585004898        0.0000000000000000\n</code></pre> <p>The next part is the same as <code>seedname_hr.dat</code>. The fifth line states the number of Wannier functions <code>num_wann</code>. The sixth line gives the number of Wigner-Seitz grid-points <code>nrpts</code>. The next block of <code>nrpts</code> integers gives the degeneracy of each Wigner-Seitz grid point, with 15 entries per line. Then, the next <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the Hamiltonian matrix element \\(H_{mn}^{(\\mathbf{R})}\\) in the WF basis, e.g.,</p> <pre><code>           7\n          93\n    4    6    2    2    2    1    2    2    1    1    2    6    2    2    2\n    6    2    2    4    1    1    1    4    1    1    1    1    2    1    1\n    1    2    2    1    1    2    4    2    1    2    1    1    1    1    2\n    1    1    1    2    1    1    1    1    2    1    2    4    2    1    1\n    2    2    1    1    1    2    1    1    1    1    4    1    1    1    4\n    2    2    6    2    2    2    6    2    1    1    2    2    1    2    2\n    2    6    4\n\n   -3    1    1\n    1    1    0.42351556E-02 -0.95722060E-07\n    2    1    0.69481480E-07 -0.20318638E-06\n    3    1    0.10966508E-06 -0.13983284E-06\n    .\n    .\n    .\n</code></pre> <p>Finally, the last part is the same as <code>seedname_r.dat</code>. The <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the position matrix element in the WF basis (the float numbers in columns 3 and 4 are the real and imaginary parts for \\(\\langle m\\mathbf{0}|\\mathbf{r}_x|n\\mathbf{R}\\rangle\\), columns 5 and 6 for \\(\\langle m\\mathbf{0}|\\mathbf{r}_y|n\\mathbf{R}\\rangle\\), and columns 7 and 8 for \\(\\langle m\\mathbf{0}|\\mathbf{r}_z|n\\mathbf{R}\\rangle\\)), e.g.</p> <pre><code>   -3    1    1\n    1    1    0.32277552E-09  0.21174901E-08 -0.85436987E-09  0.26851510E-08  ...\n    2    1   -0.18881883E-08  0.21786973E-08  0.31123076E-03  0.39228431E-08  ...\n    3    1    0.31123242E-03 -0.35322230E-09  0.70867281E-09  0.10433480E-09  ...\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seednamebvec","title":"<code>seedname.bvec</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_bvec#=\\verb#true#\\). This file contains the matrix elements of bvector and their weights. The first line gives the date and time at which the file was created. The second line states the number of k-points and the total number of neighbours for each k-point <code>nntot</code>. Then all the other lines contain the b-vector (x,y,z) coordinate and weigths for each k-points and each of its neighbours.</p>"},{"location":"user_guide/wannier90/files/#seedname_wsvecdat","title":"<code>seedname_wsvec.dat</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_hr#=\\verb#true#\\) or \\(\\verb#write_rmn#=\\verb#true#\\) or \\(\\verb#write_tb#=\\verb#true#\\). The first line gives the date and time at which the file was created and the value of <code>use_ws_distance</code>. For each pair of Wannier functions (identified by the components of the vector \\(\\mathbf{R}\\) separating their unit cells and their indices) it gives: (i) the number of lattice vectors of the periodic supercell \\(\\mathbf{T}\\) that bring the Wannier function in \\(\\mathbf{R}\\) back in the Wigner-Seitz cell centred on the other Wannier function and (ii) the set of superlattice vectors \\(\\mathbf{T}\\) to make this transformation. These superlattice vectors \\(\\mathbf{T}\\) should be added to the \\(\\mathbf{R}\\) vector to obtain the correct centre of the Wannier function that underlies a given matrix element (e.g. the Hamiltonian matrix elements in <code>seedname_hr.dat</code>) in order to correctly interpolate in reciprocal space.</p> <pre><code>## written on 20Sep2016 at 18:12:37  with use_ws_distance=.true.\n    0    0    0    1    1\n    1\n    0    0    0\n    0    0    0    1    2\n    1\n    0    0    0\n    0    0    0    1    3\n    1\n    0    0    0\n    0    0    0    1    4\n    1\n    0    0    0\n    0    0    0    1    5\n    1\n    0    0    0\n    0    0    0    1    6\n    2\n    0   -1   -1\n    1   -1   -1\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_qcdat","title":"<code>seedname_qc.dat</code>","text":"<p>OUTPUT. Written if \\(\\verb#transport#=\\verb#.TRUE.#\\). The first line gives the date and time at which the file was created. In the subsequent lines, the energy value in units of eV is written in the left column, and the quantum conductance in units of \\(\\frac{2e^2}{h}\\) (\\(\\frac{e^2}{h}\\) for a spin-polarized system) is written in the right column.</p> <pre><code> ## written on 14Dec2007 at 11:30:17\n   -3.000000       8.999999\n   -2.990000       8.999999\n   -2.980000       8.999999\n   -2.970000       8.999999\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_dosdat","title":"<code>seedname_dos.dat</code>","text":"<p>OUTPUT. Written if \\(\\verb#transport#=\\verb#.TRUE.#\\). The first line gives the date and time at which the file was created. In the subsequent lines, the energy value in units of eV is written in the left column, and the density of states in an arbitrary unit is written in the right column.</p> <pre><code> ## written on 14Dec2007 at 11:30:17\n   -3.000000       6.801199\n   -2.990000       6.717692\n   -2.980000       6.640828\n   -2.970000       6.569910\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htbdat","title":"<code>seedname_htB.dat</code>","text":"<p>INPUT/OUTPUT. Read if \\(\\verb#transport_mode#=\\verb#bulk#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\). Written if \\(\\verb#tran_write_ht#=\\verb#.TRUE.#\\). The first line gives the date and time at which the file was created. The second line gives <code>tran_num_bb</code>. The subsequent lines contain <code>tran_num_bb</code>\\(\\times\\)<code>tran_num_bb</code> \\(H_{mn}\\) matrix, where the indices \\(m\\) and \\(n\\) span all <code>tran_num_bb</code> WFs located at \\(0^{\\mathrm{th}}\\) principal layer. Then <code>tran_num_bb</code> is recorded again in the new line followed by \\(H_{mn}\\), where \\(m^{\\mathrm{th}}\\) WF is at \\(0^{\\mathrm{th}}\\) principal layer and \\(n^{\\mathrm{th}}\\) at \\(1^{\\mathrm{st}}\\) principal layer. The \\(H_{mn}\\) matrix is written in such a way that \\(m\\) is the fastest varying index.</p> <pre><code> written on 14Dec2007 at 11:30:17\n   150\n   -1.737841   -2.941054    0.052673   -0.032926    0.010738   -0.009515\n    0.011737   -0.016325    0.051863   -0.170897   -2.170467    0.202254\n    .\n    .\n    .\n   -0.057064   -0.571967   -0.691431    0.015155   -0.007859    0.000474\n   -0.000107   -0.001141   -0.002126    0.019188   -0.686423  -10.379876\n   150\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000   -0.001576\n    0.000255   -0.000143   -0.001264    0.002278    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htldat","title":"<code>seedname_htL.dat</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\). The file must be written in the same way as in <code>seedname_htB.dat</code>. The first line can be any comment you want. The second line gives <code>tran_num_ll</code>. <code>tran_num_ll</code> in <code>seedname_htL.dat</code> must be equal to that in <code>seedname.win</code>. The code will stop otherwise.</p> <pre><code> Created by a WANNIER user\n   105\n    0.316879    0.000000   -2.762434    0.048956    0.000000   -0.016639\n    0.000000    0.000000    0.000000    0.000000    0.000000   -2.809405\n    .\n    .\n    .\n    0.000000    0.078188    0.000000    0.000000   -2.086453   -0.001535\n    0.007878   -0.545485  -10.525435\n   105\n    0.000000    0.000000    0.000315   -0.000294    0.000000    0.000085\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000021\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htrdat","title":"<code>seedname_htR.dat</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\) and \\(\\verb#tran_use_same_lead#=\\verb#.FALSE.#\\). The file must be written in the same way as in <code>seedname_htL.dat</code>. <code>tran_num_rr</code> in <code>seedname_htR.dat</code> must be equal to that in <code>seedname.win</code>.</p>"},{"location":"user_guide/wannier90/files/#seedname_htcdat","title":"<code>seedname_htC.dat</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\). The first line can be any comment you want. The second line gives <code>tran_num_cc</code>. The subsequent lines contain <code>tran_num_cc</code>\\(\\times\\)<code>tran_num_cc</code> \\(H_{mn}\\) matrix, where the indices \\(m\\) and \\(n\\) span all <code>tran_num_cc</code> WFs inside the central conductor region. <code>tran_num_cc</code> in <code>seedname_htC.dat</code> must be equal to that in <code>seedname.win</code>.</p> <pre><code> Created by a WANNIER user\n    99\n  -10.499455   -0.541232    0.007684   -0.001624   -2.067078   -0.412188\n    0.003217    0.076965    0.000522   -0.000414    0.000419   -2.122184\n    .\n    .\n    .\n   -0.003438    0.078545    0.024426    0.757343   -2.004899   -0.001632\n    0.007807   -0.542983  -10.516896\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htlcdat","title":"<code>seedname_htLC.dat</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\). The first line can be any comment you want. The second line gives <code>tran_num_ll</code> and <code>tran_num_lc</code> in the given order. The subsequent lines contain <code>tran_num_ll</code>\\(\\times\\)<code>tran_num_lc</code> \\(H_{mn}\\) matrix. The index \\(m\\) spans <code>tran_num_ll</code> WFs in the surface principal layer of semi-infinite left lead which is in contact with the conductor region. The index \\(n\\) spans <code>tran_num_lc</code> WFs in the conductor region which have a non-negligible interaction with the WFs in the semi-infinite left lead. Note that <code>tran_num_lc</code> can be different from <code>tran_num_cc</code>.</p> <pre><code> Created by a WANNIER user\n   105    99\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    .\n    .\n    .\n   -0.000003    0.000009    0.000290    0.000001   -0.000007   -0.000008\n    0.000053   -0.000077   -0.000069\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htcrdat","title":"<code>seedname_htCR.dat</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.TRUE.#\\). The first line can be any comment you want. The second line gives <code>tran_num_cr</code> and <code>tran_num_rr</code> in the given order. The subsequent lines contain <code>tran_num_cr</code>\\(\\times\\)<code>tran_num_rr</code> \\(H_{mn}\\) matrix. The index \\(m\\) spans <code>tran_num_cr</code> WFs in the conductor region which have a non-negligible interaction with the WFs in the semi-infinite right lead. The index \\(n\\) spans <code>tran_num_rr</code> WFs in the surface principal layer of semi-infinite right lead which is in contact with the conductor region. Note that <code>tran_num_cr</code> can be different from <code>tran_num_cc</code>.</p> <pre><code> Created by a WANNIER user\n    99   105\n   -0.000180    0.000023    0.000133   -0.000001    0.000194    0.000008\n   -0.000879   -0.000028    0.000672   -0.000257   -0.000102   -0.000029\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#sec:files_unkg","title":"<code>seedname.unkg</code>","text":"<p>INPUT. Read if \\(\\verb#transport_mode#=\\verb#lcr#\\) and \\(\\verb#tran_read_ht#=\\verb#.FALSE.#\\). The first line is the number of G-vectors at which the \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are subsequently printed. This number should always be 32 since 32 specific \\(\\tilde{u}_{m\\mathbf{k}}\\) are required. The following lines contain the following in this order: The band index \\(m\\), a counter on the number of G-vectors, the integer co-efficient of the G-vector components \\(a,b,c\\) (where \\(\\mathbf{G}=a\\mathbf{b}_1+b\\mathbf{b}_2+c\\mathbf{b}_3\\)), then the real and imaginary parts of the corresponding \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) at the \\(\\Gamma\\)-point. We note that the ordering in which the G-vectors and \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are printed is not important, but the specific G-vectors are critical. The following example displays for a single band, the complete set of \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) that are required. Note the G-vectors (\\(a,b,c\\)) needed.</p> <pre><code>      32\n    1    1    0    0    0   0.4023306   0.0000000\n    1    2    0    0    1  -0.0000325   0.0000000\n    1    3    0    1    0  -0.3043665   0.0000000\n    1    4    1    0    0  -0.3043665   0.0000000\n    1    5    2    0    0   0.1447143   0.0000000\n    1    6    1   -1    0   0.2345179   0.0000000\n    1    7    1    1    0   0.2345179   0.0000000\n    1    8    1    0   -1   0.0000246   0.0000000\n    1    9    1    0    1   0.0000246   0.0000000\n    1   10    0    2    0   0.1447143   0.0000000\n    1   11    0    1   -1   0.0000246   0.0000000\n    1   12    0    1    1   0.0000246   0.0000000\n    1   13    0    0    2   0.0000338   0.0000000\n    1   14    3    0    0  -0.0482918   0.0000000\n    1   15    2   -1    0  -0.1152414   0.0000000\n    1   16    2    1    0  -0.1152414   0.0000000\n    1   17    2    0   -1  -0.0000117   0.0000000\n    1   18    2    0    1  -0.0000117   0.0000000\n    1   19    1   -2    0  -0.1152414   0.0000000\n    1   20    1    2    0  -0.1152414   0.0000000\n    1   21    1   -1   -1  -0.0000190   0.0000000\n    1   22    1   -1    1  -0.0000190   0.0000000\n    1   23    1    1   -1  -0.0000190   0.0000000\n    1   24    1    1    1  -0.0000190   0.0000000\n    1   25    1    0   -2  -0.0000257   0.0000000\n    1   26    1    0    2  -0.0000257   0.0000000\n    1   27    0    3    0  -0.0482918   0.0000000\n    1   28    0    2   -1  -0.0000117   0.0000000\n    1   29    0    2    1  -0.0000117   0.0000000\n    1   30    0    1   -2  -0.0000257   0.0000000\n    1   31    0    1    2  -0.0000257   0.0000000\n    1   32    0    0    3   0.0000187   0.0000000\n    2    1    0    0    0  -0.0000461   0.0000000\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_umat","title":"<code>seedname_u.mat</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_u_matrices#=\\verb#.TRUE.#\\). The first line gives the date and time at which the file was created. The second line states the number of kpoints <code>num_kpts</code> and the number of wannier functions <code>num_wann</code> twice. The third line is empty. Then there are <code>num_kpts</code> blocks of data, each of which starts with a line containing the kpoint (in fractional coordinates of the reciprocal lattice vectors) followed by <code>num_wann * num_wann</code> lines containing the matrix elements (real and imaginary parts) of \\(\\mathbf{U}^{(\\mathbf{k})}\\). The matrix elements are in column-major order (ie, cycling over rows first and then columns). There is an empty line between each block of data.</p> <pre><code> written on 15Sep2016 at 16:33:46 \n           64           8           8\n\n   0.0000000000  +0.0000000000  +0.0000000000\n   0.4468355787  +0.1394579978\n  -0.0966033667  +0.4003934902\n  -0.0007748974  +0.0011788678\n  -0.0041177339  +0.0093821027\n   .\n   .\n   .\n\n   0.1250000000   0.0000000000  +0.0000000000\n   0.4694005589  +0.0364941808\n  +0.2287801742  -0.1135511138\n  -0.4776782452  -0.0511719121\n  +0.0142081014  +0.0006203139\n   .\n   .\n   .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_u_dismat","title":"<code>seedname_u_dis.mat</code>","text":"<p>OUTPUT. Written if \\(\\verb#write_u_matrices#=\\verb#.TRUE.#\\) and disentanglement is enabled. The first line gives the date and time at which the file was created. The second line states the number of kpoints <code>num_kpts</code>, the number of wannier functions <code>num_bands</code> and the number of <code>num_bands</code>. The third line is empty. Then there are <code>num_kpts</code> blocks of data, each of which starts with a line containing the kpoint (in fractional coordinates of the reciprocal lattice vectors) followed by <code>num_wann * num_bands</code> lines containing the matrix elements (real and imaginary parts) of \\(\\mathbf{U}^{\\mathrm{dis}(\\mathbf{k})}\\). The matrix elements are in column-major order (ie, cycling over rows first and then columns). There is an empty line between each block of data.</p> <pre><code> written on 15Sep2016 at 16:33:46 \n           64           8          16\n\n   0.0000000000  +0.0000000000  +0.0000000000\n   1.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n   .\n   .\n   .\n\n   0.1250000000   0.0000000000  +0.0000000000\n   1.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n   .\n   .\n   .\n</code></pre> <ol> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9</p> </li> <li> <p>Runzhi Wang, Emanuel A. Lazar, Hyowon Park, Andrew J. Millis, and Chris A. Marianetti. Selectively localized wannier functions. Physical Review B, 10 2014. doi:10.1103/PhysRevB.90.165125.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/library_mode/","title":"<code>wannier90</code>\u00a0as a library","text":"<p>This is a description of the interface between any external program and the wannier code. There are two subroutines: <code>wannier_setup</code> and <code>wannier_run</code>. Calling <code>wannier_setup</code> will return information required to construct the \\(M_{mn}^{(\\mathbf{k,b})}\\) overlaps (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)) and \\(A_{mn}^{(\\mathbf{k})}=\\left\\langle   \\psi_{m\\mathbf{k}}|g_{n}\\right\\rangle\\) projections (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)). Once the overlaps and projection have been computed, calling <code>wannier_run</code> activates the minimisation and plotting routines in <code>wannier90</code>.</p> <p>IMPORTANT NOTE: the library mode ONLY works in serial. Please call it from a serial code, or if compiled in parallel, make sure to run it from a single MPI process.</p> <p>You can find a minimal example of how the library mode can be used among the tests, in the file <code>test-suite/library-mode-test/test_library.F90</code> in the Wannier90 git repository.</p>"},{"location":"user_guide/wannier90/library_mode/#subroutines","title":"Subroutines","text":""},{"location":"user_guide/wannier90/library_mode/#wannier_setup","title":"<code>wannier_setup</code>","text":"<p><code>wannier_setup(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice,</code>\\ <code>kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart,</code>\\ <code>gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann,proj_site,</code>\\ <code>proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona,</code>\\ <code>exclude_bands,proj_s,proj_s_qaxis)</code></p> <p>Conditions:</p> <ul> <li> <p>\\(\\verb#num_kpts# = \\verb#mp_grid(1)# \\times \\verb#mp_grid(2)#     \\times \\verb#mp_grid(3)#\\).</p> </li> <li> <p>\\(\\verb#num_nnmax# = 12\\)</p> </li> </ul> <p>This subroutine returns the information required to determine the required overlap elements \\(M_{mn}^{(\\mathbf{k,b})}\\) and projections \\(A_{mn}^{(\\mathbf{k})}\\), i.e., <code>M_matrix</code> and <code>A_matrix</code>, described in Section\u00a06.1.2{reference-type=\"ref\" reference=\"wannier_run\"}.</p> <p>For the avoidance of doubt, <code>real_lattice(1,2)</code> is the \\(y-\\)component of the first lattice vector \\(\\mathbf{A}_{1}\\), etc.</p> <p>The list of nearest neighbours of a particular k-point <code>nkp</code> is given by <code>nnlist(nkp,1:nntot)</code>.</p> <p>Additionally, the parameter <code>shell_list</code> may be specified in the <code>wannier90</code>\u00a0input file.</p>"},{"location":"user_guide/wannier90/library_mode/#wannier_run","title":"<code>wannier_run</code>","text":"<p><code>wannier_run(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice,</code>\\ <code>kpt_latt,num_bands,num_wann,nntot,num_atoms,atom_symbols,</code>\\ <code>atoms_cart,gamma_only,M_matrix_orig,A_matrix,eigenvalues,</code>\\ <code>U_matrix,U_matrix_opt,lwindow,wann_centres,wann_spreads,</code>\\ <code>spread</code>)</p> <ul> <li> <p><code>character(len=*), intent(in) :: seed_name</code>\\     The seedname of the current calculation.</p> </li> <li> <p><code>integer, dimension(3), intent(in) :: mp_grid</code>\\     The dimensions of the Monkhorst-Pack k-point grid.</p> </li> <li> <p><code>integer, intent(in) :: num_kpts</code>\\     The number of k-points on the Monkhorst-Pack grid.</p> </li> <li> <p><code>real(kind=dp), dimension(3,3),</code> <code>intent(in) :: real_lattice</code>\\     The lattice vectors in Cartesian co-ordinates in units of Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(3,3), intent(in) :: recip_lattice</code>\\     The reciprical lattice vectors in Cartesian co-ordinates in units of     inverse Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_kpts),</code> <code>intent(in) :: kpt_latt</code>\\     The positions of the k-points in fractional co-ordinates relative to     the reciprocal lattice vectors.</p> </li> <li> <p><code>integer, intent(in) :: num_bands</code>\\     The total number of bands to be processed.</p> </li> <li> <p><code>integer, intent(in) :: num_wann</code>\\     The number of MLWF to be extracted.</p> </li> <li> <p><code>integer, intent(in) :: nntot</code>\\     The number of nearest neighbours for each k-point.</p> </li> <li> <p><code>integer, intent(in) :: num_atoms</code>\\     The total number of atoms in the system.</p> </li> <li> <p><code>character(len=20), dimension(num_atoms),</code> <code>intent(in) :: atom_symbols</code>\\     The elemental symbols of the atoms.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_atoms),</code> <code>intent(in) :: atoms_cart</code>\\     The positions of the atoms in Cartesian co-ordinates in Angstrom.</p> </li> <li> <p><code>logical, intent(in) :: gamma_only</code>\\     Set to <code>.true.</code> if the underlying electronic structure calculation     has been performed with only \\(\\Gamma\\)-point sampling and, hence, if     the Bloch eigenstates that are used to construct     \\(A_{mn}^{(\\mathbf{k})}\\) and \\(M_{mn}^{\\mathbf{(k,b)}}\\) are real.</p> </li> <li> <p><code>complex(kind=dp),</code> <code>dimension(num_bands,num_bands,nntot,num_kpts),</code>\\     <code>intent(in) :: M_matrix</code>\\     The matrices of overlaps between neighbouring periodic parts of the     Bloch eigenstates at each k-point, \\(M_{mn}^{(\\mathbf{(k,b)})}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)).</p> </li> <li> <p><code>complex(kind=dp), dimension(num_bands,num_wann,num_kpts),</code>\\     <code>intent(in) :: A_matrix</code>\\     The matrices describing the projection of <code>num_wann</code> trial orbitals     on <code>num_bands</code> Bloch states at each k-point, \\(A_{mn}^{(\\mathbf{k})}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)).</p> </li> <li> <p><code>real(kind=dp), dimension(num_bands,num_kpts),</code> <code>intent(in) :: eigenvalues</code>\\     The eigenvalues \\(\\varepsilon_{n\\mathbf{k}}\\) corresponding to the     eigenstates, in eV.</p> </li> <li> <p><code>complex(kind=dp), dimension(num_wann,num_wann,num_kpts),</code>\\     <code>intent(out) :: U_matrix</code>\\     The unitary matrices at each k-point (Ref.\u00a0<sup>1</sup>,     Eq.\u00a0(59))</p> </li> <li> <p><code>complex(kind=dp), dimension(num_bands,num_wann,num_kpts),</code>\\     <code>optional, intent(out) :: U_matrix_opt</code>\\     The unitary matrices that describe the optimal sub-space at each     k-point (see Ref.\u00a0<sup>2</sup>, Section\u00a0IIIa). The array is packed     (see below)</p> </li> <li> <p><code>logical, dimension(num_bands,num_kpts), optional, intent(out) :: lwindow</code>\\     The element <code>lwindow(nband,nkpt)</code> is <code>.true.</code> if the band <code>nband</code>     lies within the outer energy window at kpoint <code>nkpt</code>.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_wann), optional, intent(out) :: wann_centres</code>\\     The centres of the MLWF in Cartesian co-ordinates in Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(num_wann), optional, intent(out) :: wann_spreads</code>\\     The spread of each MLWF in \u00c5\\(^{2}\\).</p> </li> <li> <p><code>real(kind=dp), dimension(3), optional, intent(out) ::</code> <code>spread</code>\\     The values of \\(\\Omega\\), \\(\\Omega_{\\mathrm{I}}\\) and \\(\\tilde{\\Omega}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(13)).</p> </li> </ul> <p>Conditions:</p> <ul> <li> <p>\\(\\verb#num_wann# \\le \\verb#num_bands#\\)</p> </li> <li> <p>\\(\\verb#num_kpts# = \\verb#mp_grid(1)# \\times \\verb#mp_grid(2)#     \\times \\verb#mp_grid(3)#\\).</p> </li> </ul> <p>If \\(\\verb#num_bands# = \\verb#num_wann#\\) then <code>U_matrix_opt</code> is the identity matrix and <code>lwindow=.true.</code></p> <p>For the avoidance of doubt, <code>real_lattice(1,2)</code> is the \\(y-\\)component of the first lattice vector \\(\\mathbf{A}_{1}\\), etc.</p> <p>\\(\\(\\begin{aligned} \\verb#M_matrix(m,n,nn,nkp)# &amp; = &amp; \\left\\langle u_{m\\mathbf{k}} | u_{n\\mathbf{k+b}}\\right\\rangle\\\\ \\verb#A_matrix(m,n,nkp)# &amp; = &amp; \\left\\langle \\psi_{m\\mathbf{k}}|g_{n}\\right\\rangle\\\\ \\verb#eigenvalues(n,nkp)# &amp;=&amp; \\varepsilon_{n\\mathbf{k}} \\end{aligned}\\)\\) where \\(\\(\\begin{aligned} \\mathbf{k} &amp;=&amp;\\verb#kpt_latt(1:3,nkp)#\\\\ \\mathbf{k+b}&amp;=&amp; \\verb#kpt_latt(1:3,nnlist(nkp,nn))# + \\verb#nncell(1:3,nkp,nn)#  \\end{aligned}\\)\\) and \\(\\left\\{|g_{n}\\rangle\\right\\}\\) are a set of initial trial orbitals. These are typically atom or bond-centred Gaussians that are modulated by appropriate spherical harmonics.</p> <p>Additional parameters should be specified in the <code>wannier90</code>\u00a0input file.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/methodology/","title":"Methodology","text":"<p><code>wannier90</code>\u00a0computes maximally-localised Wannier functions (MLWF) following the method of Marzari and Vanderbilt (MV)\u00a0<sup>1</sup>. For entangled energy bands, the method of Souza, Marzari and Vanderbilt (SMV)\u00a0<sup>2</sup> is used. We introduce briefly the methods and key definitions here, but full details can be found in the original papers and in Ref.\u00a0<sup>3</sup>.</p> <p>First-principles codes typically solve the electronic structure of periodic materials in terms of Bloch states, \\(\\psi_{n{\\bf k}}\\). These extended states are characterised by a band index \\(n\\) and crystal momentum \\({\\bf k}\\). An alternative representation can be given in terms of spatially localised functions known as Wannier functions (WF). The WF centred on a lattice site \\({\\bf R}\\), \\(w_{n{\\bf R}}({\\bf r})\\), is written in terms of the set of Bloch states as</p> \\[ w_{n{\\bf R}}({\\bf r})=\\frac{V}{(2\\pi)^3}\\int_{\\mathrm{BZ}} \\left[\\sum_{m} U^{({\\bf k})}_{mn} \\psi_{m{\\bf k}}({\\bf     r})\\right]e^{-\\mathrm{i}{\\bf k}.{\\bf R}} \\:\\mathrm{d}{\\bf k} \\ , \\] <p>where \\(V\\) is the unit cell volume, the integral is over the Brillouin zone (BZ), and \\(\\mathbf{U}^{(\\mathbf{k})}\\) is a unitary matrix that mixes the Bloch states at each \\({\\bf k}\\). \\(\\mathbf{U}^{(\\mathbf{k})}\\) is not uniquely defined and different choices will lead to WF with varying spatial localisations. We define the spread \\(\\Omega\\) of the WF as</p> \\[ \\Omega=\\sum_n \\left[\\langle w_{n{\\bf 0}}({\\bf r})| r^2 | w_{n{\\bf       0}}({\\bf r}) \\rangle - | \\langle w_{n{\\bf 0}}({\\bf r})| {\\bf r}       | w_{n{\\bf 0}}({\\bf r}) \\rangle |^2 \\right]. \\] <p>The total spread can be decomposed into a gauge invariant term \\(\\Omega_{\\rm I}\\) plus a term \\({\\tilde \\Omega}\\) that is dependant on the gauge choice \\(\\mathbf{U}^{(\\mathbf{k})}\\). \\({\\tilde \\Omega}\\) can be further divided into terms diagonal and off-diagonal in the WF basis, \\(\\Omega_{\\rm D}\\) and \\(\\Omega_{\\rm OD}\\),</p> \\[ \\Omega=\\Omega_{\\rm I}+{\\tilde \\Omega}=\\Omega_{\\rm I}+\\Omega_{\\rm   D}+\\Omega_{\\rm OD} \\] <p>where</p> \\[ \\Omega_{{\\rm I}}=\\sum_n \\left[\\langle w_{n{\\bf 0}}({\\bf r})| r^2 | w_{n{\\bf       0}}({\\bf r}) \\rangle - \\sum_{{\\bf R}m} \\left| \\langle w_{m{\\bf       R}}({\\bf r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle \\right| ^2       \\right] \\] \\[ \\Omega_{\\rm D}=\\sum_n \\sum_{{\\bf R}\\neq{\\bf 0}} |\\langle w_{n{\\bf     R}}({\\bf r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle|^2 \\] \\[ \\Omega_{\\rm OD}=\\sum_{m\\neq n} \\sum_{{\\bf R}} |\\langle w_{m{\\bf R}}({\\bf   r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle |^2 \\] <p>The MV method minimises the gauge dependent spread \\(\\tilde{\\Omega}\\) with respect the set of \\(\\mathbf{U}^{(\\mathbf{k})}\\) to obtain MLWF.</p> <p><code>wannier90</code>\u00a0requires two ingredients from an initial electronic structure calculation.</p> <ol> <li> <p>The overlaps between the cell periodic part of the Bloch states     \\(|u_{n{\\bf k}}\\rangle\\)</p> \\[ M_{mn}^{(\\bf{k,b})}=\\langle u_{m{\\bf k}}|u_{n{\\bf k}+{\\bf b}}\\rangle, \\] <p>where the vectors \\({\\bf b}\\), which connect a given k-point with its neighbours, are determined by <code>wannier90</code>\u00a0according to the prescription outlined in Ref.\u00a0<sup>1</sup>.</p> </li> <li> <p>As a starting guess the projection of the Bloch states     \\(|\\psi_{n\\bf{k}}\\rangle\\) onto trial localised orbitals     \\(|g_{n}\\rangle\\)</p> \\[ A_{mn}^{(\\bf{k})}=\\langle \\psi_{m{\\bf k}}|g_{n}\\rangle, \\] </li> </ol> <p>Note that \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\), \\(\\mathbf{A}^{(\\mathbf{k})}\\) and \\(\\mathbf{U}^{(\\mathbf{k})}\\) are all small, \\(N \\times N\\) matrices (see the following note) that are independent of the basis set used to obtain the original Bloch states.</p> <p>Note</p> <p>Technically, this is true for the case of an isolated group of \\(N\\) bands from which we obtain \\(N\\) MLWF. When using the disentanglement procedure of Ref.\u00a0<sup>2</sup>, \\(\\mathbf{A}^{(\\mathbf{k})}\\), for example, is a rectangular matrix. See Section\u00a0Entangled Energy Bands.</p> <p>To date, <code>wannier90</code>\u00a0has been used in combination with electronic codes based on plane-waves and pseudopotentials (norm-conserving and ultrasoft\u00a0<sup>4</sup>) as well as mixed basis set techniques such as FLAPW\u00a0<sup>5</sup>.</p>"},{"location":"user_guide/wannier90/methodology/#entangled-energy-bands","title":"Entangled Energy Bands","text":"<p>The above description is sufficient to obtain MLWF for an isolated set of bands, such as the valence states in an insulator. In order to obtain MLWF for entangled energy bands we use the \"disentanglement\" procedure introduced in Ref.\u00a0<sup>2</sup>.</p> <p>We define an energy window (the \"outer window\"). At a given k-point \\(\\bf{k}\\), \\(N^{({\\bf k})}_{{\\rm win}}\\) states lie within this energy window. We obtain a set of \\(N\\) Bloch states by performing a unitary transformation amongst the Bloch states which fall within the energy window at each k-point:</p> \\[ | u_{n{\\bf k}}^{{\\rm opt}}\\rangle = \\sum_{m\\in N^{({\\bf k})}_{{\\rm win}}} U^{{\\rm dis}({\\bf k})}_{mn} | u_{m{\\bf k}}\\rangle \\] <p>where \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\) is a rectangular \\(N^{({\\bf k})}_{{\\rm win}} \\times N\\) matrix (see the following note). The set of \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\) are obtained by minimising the gauge invariant spread \\(\\Omega_{{\\rm I}}\\) within the outer energy window. The MV procedure can then be used to minimise \\(\\tilde{\\Omega}\\) and hence obtain MLWF for this optimal subspace.</p> <p>Note</p> <p>As \\({\\bf U}^{{\\rm dis}({\\bf k})}\\) is a rectangular matrix this is a unitary operation in the sense that \\(({\\bf U}^{{\\rm  dis}({\\bf k})})^{\\dagger}{\\bf U}^{{\\rm dis}({\\bf k})}={\\bf 1}_N\\).</p> <p>It should be noted that the energy bands of this optimal subspace may not correspond to any of the original energy bands (due to mixing between states). In order to preserve exactly the properties of a system in a given energy range (e.g., around the Fermi level) we introduce a second energy window. States lying within this inner, or \"frozen\", energy window are included unchanged in the optimal subspace.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>A. A. Mostofi, J. R. Yates, Y.-S. Lee, I. Souza, D. Vanderbilt, and N. Marzari. Wannier90: a tool for obtaining maximally-localised wannier functions. Comput. Phys. Commun., 178:685, 2008.\u00a0\u21a9</p> </li> <li> <p>D. Vanderbilt. Phys. Rev. B, 41:7892, 1990.\u00a0\u21a9</p> </li> <li> <p>M. Posternak, A. Baldereschi, S. Massidda, and N. Marzari. Maximally localized wannier functions in antiferromagnetic mno within the flapw formalism. Phys. Rev. B, 65:184422, 2002.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/notes_interpolations/","title":"Some notes on the interpolation","text":"<p>In <code>wannier90</code> v.2.1, a new flag <code>use_ws_distance</code> has been introduced (and it is set to <code>.true.</code> by default since version v3.0). Setting it to <code>.false.</code> reproduces the \"standard\" behavior of <code>wannier90</code> in v.2.0.1 and earlier, while setting it to <code>.true.</code> changes the interpolation method as described below. In general, this allows a smoother interpolation, helps reducing (a bit) the number of \\(k-\\)points required for interpolation, and reproduces the band structure of large supercells sampled at \\(\\Gamma\\) only (setting it to <code>.false.</code> produces instead flat bands, which might instead be the intended behaviour for small molecules carefully placed at the centre of the cell).</p> <p>The core idea rests on the fact that the Wannier functions \\(w_{n\\bm{\\mathrm{R}}}(\\bm{\\mathrm{r}})\\) that we build from \\(N\\times M\\times L\\) \\(k-\\)points are actually periodic over a supercell of size \\(N\\times M\\times L\\), but when you use them to interpolate you want them to be zero outside this supercell. In 1D it is pretty obvious want we mean here, but in 3D what you really want that they are zero outside the Wigner--Seitz cell of the \\(N\\times M\\times L\\) superlattice.</p> <p>The best way to impose this condition is to check that every real-space distance that enters in the \\(R\\to k\\) Fourier transform is the shortest possible among all the \\(N\\times M\\times L-\\)periodic equivalent copies.</p> <p>If the distances were between unit cells, this would be trivial, but the distances are between Wannier functions which are not centred on \\(\\bm{\\mathrm{R}}=0\\). Hence, when you want to consider the matrix element of a generic operator \\(\\bm{\\mathrm{O}}\\) (i.e., the Hamiltonian) \\(\\langle w_{i\\bm{\\mathrm{0}}}(\\bm{\\mathrm{r}})|\\bm{\\mathrm{O}}|w_{j\\bm{\\mathrm{R}}}(\\bm{\\mathrm{r}})\\rangle\\) you must take in account that the centre \\(\\bm{\\mathrm{\\tau}}_i\\) of \\(w_{i\\bm{\\mathrm{0}}}(\\bm{\\mathrm{r}})\\) may be very far away from \\(\\bm{\\mathrm{0}}\\) and the centre \\(\\bm{\\mathrm{\\tau}}_j\\) of \\(w_{j\\bm{\\mathrm{R}}}(\\bm{\\mathrm{r}})\\) may be very far away from \\(\\bm{\\mathrm{R}}\\).</p> <p>There are many way to find the shortest possible distance between \\(w_{i\\bm{\\mathrm{0}}}(\\bm{\\mathrm{r}})\\) and \\(w_{j\\bm{\\mathrm{R}}}(\\bm{\\mathrm{r}}-\\bm{\\mathrm{R}})\\), the one used here is to consider the distance \\(\\bm{\\mathrm{d}}_{ij\\bm{\\mathrm{R}}} = \\bm{\\mathrm{\\tau}}_i - (\\bm{\\mathrm{\\tau}}_j+\\bm{\\mathrm{R}})\\) and all its superlattice periodic equivalents \\(\\bm{\\mathrm{d}}_{ij\\bm{\\mathrm{R}}}+ \\bm{\\mathrm{\\tilde R}}_{nml}\\), with \\(\\bm{\\mathrm{\\tilde R}}_{nml} = (Nn\\bm{\\mathrm{a}}_1 + Mm\\bm{\\mathrm{a}}_2 + Ll\\bm{\\mathrm{a}}_3)\\) and \\(n,l,m = {-L,-L+1,...0,...,L-1,L}\\), with \\(L\\) controlled by the parameter <code>ws_search_size</code>.</p> <p>Then,</p> <ol> <li> <p>if     \\(\\bm{\\mathrm{d}}_{ij\\bm{\\mathrm{R}}}+ \\bm{\\mathrm{\\tilde R}}_{nml}\\)     is inside the \\(N\\times M \\times L\\) super-WS cell, then it is the     shortest, take it and quit</p> </li> <li> <p>if it is outside the WS, then it is not the shortest, throw it away</p> </li> <li> <p>if it is on the border/corner of the WS then it is the shortest, but     there are other choices of \\((n,m,l)\\) which are equivalent, find all     of them</p> </li> </ol> <p>In all distance comparisons, a small but finite tolerance is considered, which can be controlled with the parameter <code>ws_distance_tol</code>.</p> <p>Because of how the Fourier transform is defined in the <code>wannier90</code> code (not the only possible choice) it is only \\(\\bm{\\mathrm{R}}+\\bm{\\mathrm{\\tilde R}}_{nml}\\) that enters the exponential, but you still have to consider the distance among the actual centres of the Wannier functions. Using the centres of the unit-cell to which the Wannier functions belong is not enough (but is easier, and saves you one index).</p> <p>Point 3 is not stricly necessary, but using it helps enforcing the symmetry of the system in the resulting band structure. You will get some small but evident symmetry breaking in the band plots if you just pick one of the equivalent \\(\\bm{\\mathrm{\\tilde R}}\\) vectors.</p> <p>Note that in some cases, all this procedure does absolutely nothing, for instance if all the Wannier function centres are very close to 0 (e.g., a molecule carefully placed in the periodic cell).</p> <p>In some other cases, the effect may exist but be imperceptible. E.g., if you use a very fine grid of \\(k-\\)points, even if you don't centre each functions perfectly, the periodic copies will still be so far away that the change in centre applied with \\(\\tt use\\_ws\\_distance\\) does not matter.</p> <p>When instead you use few \\(k-\\)points, activating the \\(\\tt use\\_ws\\_distance\\) may help a lot in avoiding spurious oscillations of the band structure even when the Wannier functions are well converged.</p>"},{"location":"user_guide/wannier90/parameters/","title":"Parameters","text":""},{"location":"user_guide/wannier90/parameters/#usage","title":"Usage","text":"<p><code>wannier90.x</code> can be run in parallel using MPI libraries to reduce the computation time.</p> <p>For serial execution use: <code>wannier90.x [-pp] [seedname]</code></p> <ul> <li> <p><code>seedname</code>: If a seedname string is given the code will read its     input from a file <code>seedname.win</code>. The default value is <code>wannier</code>.     One can also equivalently provide the string <code>seedname.win</code> instead     of <code>seedname</code>.</p> </li> <li> <p><code>-pp</code>: This optional flag tells the code to generate a list of the     required overlaps and then exit. This information is written to the     file <code>seedname.nnkp</code>.</p> </li> </ul> <p>For parallel execution use: <code>mpirun -np NUMPROCS wannier90.x [-pp] [seedname]</code></p> <ul> <li><code>NUMPROCS</code>: substitute with the number of processors that you want     to use.</li> </ul> <p>Note that the <code>mpirun</code> command and command-line flags may be different in your MPI implementation: read your MPI manual or ask your computer administrator.</p> <p>Note also that this requires that the <code>wannier90.x</code> executable has been compiled in its parallel version (follow the instructions in the file <code>README.install</code> in the main directory of the wannier90 distribution) and that the MPI libraries and binaries are installed and correctly configured on your machine.</p>"},{"location":"user_guide/wannier90/parameters/#seednamewin-file","title":"<code>seedname.win</code> File","text":"<p>The <code>wannier90</code>\u00a0input file <code>seedname.win</code> has a flexible free-form structure.</p> <p>The ordering of the keywords is not significant. Case is ignored (so <code>num_bands</code> is the same as <code>Num_Bands</code>). Characters after !, or # are treated as comments. Most keywords have a default value that is used unless the keyword is given in <code>seedname.win</code>. Keywords can be set in any of the following ways</p> <pre><code>num_wann 4\nnum_wann = 4\nnum_wann : 4\n</code></pre> <p>A logical keyword can be set to <code>true</code> using any of the following strings: <code>T</code>, <code>true</code>, <code>.true.</code>.</p> <p>For further examples see Section\u00a010.1{reference-type=\"ref\" reference=\"winfile\"} and the the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/parameters/#keyword-list","title":"Keyword List","text":"<pre><code>    Keyword        Type  Description\n</code></pre> <p>System Parameters               num_wann         I    Number of WF        num_bands        I    Number of bands passed to the code     unit_cell_cart      P    Unit cell vectors in Cartesian coordinates      atoms_cart *      P    Positions of atoms in Cartesian coordinates      atoms_frac *      R    Positions of atoms in fractional coordinates with respect to the lattice vectors         mp_grid         I    Dimensions of the Monkhorst-Pack grid of k-points         kpoints         R    List of k-points in the Monkhorst-Pack grid       gamma_only        L    Wavefunctions from underlying ab initio calculation are manifestly real         spinors         L    WF are spinors       shell_list        I    Which shells to use in finite difference formula      search_shells      I    The number of shells to search when determining finite difference formula      skip_B1_tests      L    Check the condition B1 of Ref.\u00a0<sup>1</sup>         nnkpts          I    Explicit list of nearest-neighbour k-points.        kmesh_tol        R    The tolerance to control if two kpoint belong to the same shell</p> <code>seedname.win</code> file keywords defining the system. Argument types are   represented by, I for a integer, R for a real number, P for a physical   value, L for a logical value and S for a text string.\\   * atoms_cart and atoms_frac may not both be defined in the same input   file. ::: ::: <p>::: center ::: {#parameter_keywords2}</p> <pre><code>     Keyword          Type  Description\n\n   Job Control              \n  postproc_setup       L    To output the `seedname.nnkp` file\n  exclude_bands        I    List of bands to exclude from the calculation\nselect_projections     I    List of projections to use in Wannierisation\n auto_projections      L    To automatically generate initial projections\n     restart           S    Restart from checkpoint file\n      iprint           I    Output verbosity level\n   length_unit         S    System of units to output lengths\n  wvfn_formatted       L    Read the wavefunctions from a (un)formatted file\n       spin            S    Which spin channel to read\n    devel_flag         S    Flag for development use\n   timing_level        I    Determines amount of timing information written to output\n   optimisation        I    Optimisation level\n</code></pre> <p>translate_home_cell     L    To translate final Wannier centres to home unit cell when writing xyz file         write_xyz          L    To write atomic positions and final centres in xyz file format       write_vdw_data       L    To write data for futher processing by w90vdw utility       write_hr_diag        L    To write the diagonal elements of the Hamiltonian in the Wannier basis to seedname.wout (in eV)</p> <code>seedname.win</code> file keywords defining job control. Argument types   are represented by, I for a integer, R for a real number, P for a   physical value, L for a logical value and S for a text string.   translate_home_cell only relevant if write_xyz is <code>.true.</code> ::: ::: <p>::: center ::: {#parameter_keywords4}</p> <pre><code>        Keyword             Type  Description\n</code></pre> <p>Disentanglement Parameters                  dis_win_min            P    Bottom of the outer energy window           dis_win_max            P    Top of the outer energy window           dis_froz_min           P    Bottom of the inner (frozen) energy window           dis_froz_max           P    Top of the inner (frozen) energy window          dis_froz_proj           L    To activate projectability disentanglement           dis_proj_min           P    Lower threshold for projectability disentanglement           dis_proj_max           P    Upper threshold for projectability disentanglement           dis_num_iter           I    Number of iterations for the minimisation of \\(\\Omega_{\\mathrm{I}}\\)          dis_mix_ratio           R    Mixing ratio during the minimisation of \\(\\Omega_{\\mathrm{I}}\\)           dis_conv_tol           R    The convergence tolerance for finding \\(\\Omega_{\\mathrm{I}}\\)         dis_conv_window          I    The number of iterations over which convergence of \\(\\Omega_{\\mathrm{I}}\\) is assessed.         dis_spheres_num          I    Number of spheres in k-space where disentaglement is performed      dis_spheres_first_wann      I    Index of the first band to be considered a Wannier function           dis_spheres            R    List of centres and radii, for disentanglement only in spheres</p> <code>seedname.win</code> file keywords controlling the disentanglement.   Argument types are represented by, I for a integer, R for a real   number, P for a physical value, L for a logical value and S for a text   string. ::: ::: <p>::: center ::: {#parameter_keywords5}</p> <pre><code>      Keyword          Type  Description\n</code></pre> <p>Wannierise Parameters                 num_iter           I    Number of iterations for the minimisation of \\(\\Omega\\)        num_cg_steps         I    During the minimisation of \\(\\Omega\\) the number of Conjugate Gradient steps before resetting to Steepest Descents         conv_window         I    The number of iterations over which convergence of \\(\\Omega\\) is assessed          conv_tol           P    The convergence tolerance for finding \\(\\Omega\\)           precond           L    Use preconditioning       conv_noise_amp        R    The amplitude of random noise applied towards end of minimisation procedure       conv_noise_num        I    The number of times random noise is applied       num_dump_cycles       I    Control frequency of check-pointing      num_print_cycles       I    Control frequency of printing         write_r2mn          L    Write matrix elements of \\(r^2\\) between WF to file       guiding_centres       L    Use guiding centres      num_guide_cycles       I    Frequency of guiding centres      num_no_guide_iter      I    The number of iterations after which guiding centres are used        trial_step *        R    The trial step length for the parabolic line search during the minimisation of \\(\\Omega\\)        fixed_step *        R    The fixed step length to take during the minimisation of \\(\\Omega\\), instead of doing a parabolic line search    use_bloch_phases **    L    To use phases for initial projections     site_symmetry***     L    To construct symmetry-adapted Wannier functions    symmetrize_eps***     R    The convergence tolerance used in the symmetry-adapted mode          slwf_num           I    The number of objective WFs for selective localization       slwf_constrain        L    Whether to constrain the centres of the objective WFs         slwf_lambda         R    Value of the Lagrange multiplier for constraining the objective WFs        slwf_centres         P    The centres to which the objective WFs are to be constrained</p> <code>seedname.win</code> file keywords controlling the wannierisation.   Argument types are represented by, I for a integer, R for a real   number, P for a physical value, L for a logical value and S for a text   string. * fixed_step and trial_step may not both be defined in the   same input file. **Cannot be used in conjunction with   disentanglement. ***Cannot be used in conjunction with the inner   (frozen) energy window. ::: ::: <p>::: {#parameter_keywords6}</p> <pre><code>               Keyword                    Type  Description\n\n           Plot Parameters                      \n             wannier_plot                  L    Plot the WF\n          wannier_plot_list                I    List of WF to plot\n        wannier_plot_supercell             I    Size of the supercell for plotting the WF\n         wannier_plot_format               S    File format in which to plot the WF\n          wannier_plot_mode                S    Mode in which to plot the WF, molecule or crystal\n         wannier_plot_radius               R    Cut-off radius of WF\\*\n          wannier_plot_scale               R    Scaling parameter for cube files\n       wannier_plot_spinor_mode            S    Quantity to plot for spinor WF\n      wannier_plot_spinor_phase            L    Include the \"phase\" when plotting spinor WF\n              bands_plot                   L    Plot interpolated band structure\n             kpoint_path                   P    K-point path for the interpolated band structure\n           bands_num_points                I    Number of points along the first section of the k-point path\n          bands_plot_format                S    File format in which to plot the interpolated bands\n          bands_plot_project               I    WF to project the band structure onto\n           bands_plot_mode                 S    Slater-Koster type interpolation or Hamiltonian cut-off\n            bands_plot_dim                 I    Dimension of the system\n          fermi_surface_plot               L    Plot the Fermi surface\n       fermi_surface_num_points            I    Number of points in the Fermi surface plot\n             fermi_energy                  P    The Fermi energy\n           fermi_energy_min                P    Lower limit of the Fermi energy range\n           fermi_energy_max                P    Upper limit of the Fermi energy range\n          fermi_energy_step                R    Step for increasing the Fermi energy in the specified range\n      fermi_surface_plot_format            S    File format for the Fermi surface plot\n    [hr_plot]{style=\"color: red\"}          L    [This parameter is not used anymore. Use write_hr instead.]{style=\"color: red\"}\n   [write_hr]{style=\"color: blue\"}         L    [Write the Hamiltonian in the WF basis]{style=\"color: blue\"}\n  [write_rmn ]{style=\"color: blue\"}        L    [Write the position operator in the WF basis]{style=\"color: blue\"}\n  [write_bvec ]{style=\"color: blue\"}       L    [Write to file the matrix elements of the bvectors and their weights]{style=\"color: blue\"}\n   [write_tb ]{style=\"color: blue\"}        L    [Write lattice vectors, Hamiltonian, and position operator in WF basis]{style=\"color: blue\"}\n              hr_cutoff                    P    Cut-off for the absolute value of the Hamiltonian\n             dist_cutoff                   P    Cut-off for the distance between WF\n           dist_cutoff_mode                S    Dimension in which the distance between WF is calculated\n       translation_centre_frac             R    Centre of the unit cell to which final WF are translated\n</code></pre> <p>[use_ws_distance ]{style=\"color: blue\"}     L    [Improve interpolation using minimum distance between WFs, see Chap.\u00a0[chap:interpolation]]{style=\"color: blue\"}    [ws_distance_tol ]{style=\"color: blue\"}     R    [Absolute tolerance for the distance to equivalent positions.]{style=\"color: blue\"}     [ws_search_size ]{style=\"color: blue\"}     I    [Maximum extension in each direction of the super-cell of the Born-von Karmann cell to search for points inside the Wigner-Seitz cell]{style=\"color: blue\"}    [write_u_matrices ]{style=\"color: blue\"}    L    [Write \\(\\mathbf{U}^{(\\mathbf{k})}\\) and \\(\\mathbf{U}^{\\mathrm{dis}(\\mathbf{k})}\\) matrices to files]{style=\"color: blue\"}</p> <code>seedname.win</code> file keywords controlling the plotting. Argument   types are represented by, I for a integer, R for a real number, P for   a physical value, L for a logical value and S for a text string. *   Only applies when wannier_plot_format is <code>cube</code>. ::: <p>::: center ::: {#parameter_keywords7}</p> <pre><code>       Keyword            Type  Description\n\n Transport Parameters           \n      transport            L    Calculate quantum conductance and density of states\n    transport_mode         S    Bulk or left-lead_conductor_right-lead calculation\n     tran_win_min          P    Bottom of the energy window for transport calculation\n     tran_win_max          P    Top of the energy window for transport calculation\n   tran_energy_step        R    Sampling interval of the energy values\n     fermi_energy          R    The Fermi energy\n     tran_num_bb           I    Size of a bulk Hamiltonian\n     tran_num_ll           I    Size of a left-lead Hamiltonian\n     tran_num_rr           I    Size of a right-lead Hamiltonian\n     tran_num_cc           I    Size of a conductor Hamiltonian\n     tran_num_lc           I    Number of columns in a left-lead_conductor Hamiltonian\n     tran_num_cr           I    Number of rows in a conductor_right-lead Hamiltonian\n   tran_num_cell_ll        I    Number of unit cells in PL of left lead\n   tran_num_cell_rr        I    Number of unit cells in PL of right lead\n    tran_num_bandc         I    Half-bandwidth+1 of a band-diagonal conductor Hamiltonian\n    tran_write_ht          L    Write the Hamiltonian for transport calculation\n     tran_read_ht          L    Read the Hamiltonian for transport calculation\n  tran_use_same_lead       L    Left and right leads are the same\n tran_group_threshold      R    Distance that determines the grouping of WFs\n      hr_cutoff            P    Cut-off for the absolute value of the Hamiltonian\n     dist_cutoff           P    Cut-off for the distance between WF\n   dist_cutoff_mode        S    Dimension in which the distance between WF is calculated\n     one_dim_axis          S    Extended direction for a one-dimensional system\n</code></pre> <p>translation_centre_frac     R    Centre of the unit cell to which final WF are translated</p> <code>seedname.win</code> file keywords controlling transport. Argument types   are represented by, I for a integer, R for a real number, P for a   physical value, L for a logical value and S for a text string. ::: :::"},{"location":"user_guide/wannier90/parameters/#system","title":"System","text":""},{"location":"user_guide/wannier90/parameters/#integer-num_wann","title":"<code>integer :: num_wann</code>","text":"<p>Number of WF to be found.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_bands","title":"<code>integer :: num_bands</code>","text":"<p>Total number of bands passed to the code in the <code>seedname.mmn</code> file.</p> <p>Default <code>num_bands</code>=<code>num_wann</code></p>"},{"location":"user_guide/wannier90/parameters/#cell-lattice-vectors","title":"Cell Lattice Vectors","text":"<p>The cell lattice vectors should be specified in Cartesian coordinates.</p> <p><code>begin unit_cell_cart</code>\\ <code>[units]</code> \\(\\(\\begin{array}{ccc} A_{1x} &amp; A_{1y} &amp; A_{1z} \\\\ A_{2x} &amp; A_{2y} &amp; A_{2z} \\\\ A_{3x} &amp; A_{3y} &amp; A_{3z} \\end{array}\\)\\) <code>end unit_cell_cart</code></p> <p>Here \\(A_{1x}\\) is the \\(x\\)-component of the first lattice vector \\(\\mathbf{A}_1\\), \\(A_{2y}\\) is the \\(y\\)-component of the second lattice vector \\(\\mathbf{A}_2\\), etc.</p> <p><code>[units]</code> specifies the units in which the lattice vectors are defined: either <code>Bohr</code> or <code>Ang</code>.</p> <p>The default value is <code>Ang</code>.</p>"},{"location":"user_guide/wannier90/parameters/#ionic-positions","title":"Ionic Positions","text":"<p>The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute Cartesian coordinates. Only one of <code>atoms_cart</code> and <code>atoms_frac</code> may be given in the input file.</p>"},{"location":"user_guide/wannier90/parameters/#cartesian-coordinates","title":"Cartesian coordinates","text":"<p><code>begin atoms_cart</code>\\ <code>[units]</code> \\(\\(\\begin{array}{cccc} P  &amp; R^{P}_{x} &amp; R^{P}_{y} &amp; R^{P}_{z} \\\\ Q  &amp; R^{Q}_{x} &amp; R^{Q}_{y} &amp; R^{Q}_{z} \\\\ \\vdots \\end{array}\\)\\) <code>end atoms_cart</code></p> <p>The first entry on a line is the atomic symbol. The next three entries are the atom's position \\(\\mathbf{R}=(R_x , R_y, R_z)\\) in Cartesian coordinates. The first line of the block, <code>[units]</code>, specifies the units in which the coordinates are given and can be either <code>bohr</code> or <code>ang</code>. If not present, the default is <code>ang</code>.</p>"},{"location":"user_guide/wannier90/parameters/#fractional-coordinates","title":"Fractional coordinates","text":"<p><code>begin atoms_frac</code> \\(\\(\\begin{array}{cccc} P  &amp; F^{P}_{1} &amp; F^{P}_{2} &amp; F^{P}_{3} \\\\ Q  &amp; F^{Q}_{1} &amp; F^{Q}_{2} &amp; F^{Q}_{3} \\\\ \\vdots \\end{array}\\)\\) <code>end atoms_frac</code></p> <p>The first entry on a line is the atomic symbol. The next three entries are the atom's position in fractional coordinates \\(\\mathbf{F} = F_1 \\mathbf{A}_{1} + F_2 \\mathbf{A}_{2} + F_3 \\mathbf{A}_{3}\\) relative to the cell lattice vectors \\(\\mathbf{A}_i\\), \\(i\\in [1,3]\\).</p>"},{"location":"user_guide/wannier90/parameters/#integer-dimension-mp_grid3","title":"<code>integer, dimension :: mp_grid(3)</code>","text":"<p>Dimensions of the regular (Monkhorst-Pack) k-point mesh. For example, for a \\(2\\times2\\times2\\) grid:</p> <p><code>mp_grid : 2  2  2</code></p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#k-points","title":"K-points","text":"<p>Each line gives the coordinate \\(\\mathbf{K}=K_1 \\mathbf{B}_{1} + K_2 \\mathbf{B}_{2} + K_3 \\mathbf{B}_3\\) of a k-point in relative (crystallographic) units, i.e., in fractional units with respect to the primitive reciprocal lattice vectors \\(\\mathbf{B}_{i}\\), \\(i \\in [1,3]\\). The position of each k-point in this list assigns its numbering; the first k-point is k-point 1, the second is k-point 2, and so on.</p> <p><code>begin kpoints</code>\\ \\(\\(\\begin{array}{ccc}  K^{1}_{1} &amp; K^{1}_{2} &amp; K^{1}_{3} \\\\  K^{2}_{1} &amp; K^{2}_{2} &amp; K^{2}_{3} \\\\ \\vdots \\end{array}\\)\\) <code>end kpoints</code></p> <p>There is no default.</p> <p>Note: There is an utility provided with <code>wannier90</code>, called <code>kmesh.pl</code>, which helps to generate the explicit list of \\(k\\) points required by <code>wannier90</code>. See Sec.\u00a01.1{reference-type=\"ref\" reference=\"sec:kmesh\"}.</p>"},{"location":"user_guide/wannier90/parameters/#logical-gamma_only","title":"<code>logical :: gamma_only</code>","text":"<p>If <code>gamma_only=true</code>, then <code>wannier90</code>\u00a0uses a branch of algorithms for disentanglement and localisation that exploit the fact that the Bloch eigenstates obtained from the underlying ab initio calculation are manifestly real. This can be the case when only the \\(\\Gamma\\)-point is used to sample the Brillouin zone. The localisation procedure that is used in the \\(\\Gamma\\)-only branch is based on the method of Ref.\u00a0<sup>2</sup>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-spinors","title":"<code>logical :: spinors</code>","text":"<p>If <code>spinors=true</code>, then <code>wannier90</code>\u00a0assumes that the WF correspond to singularly occupied spinor states and <code>num_elec_per_state=1</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#shells","title":"Shells","text":"<p>The MV scheme requires a finite difference expression for \\(\\nabla_{\\bf k}\\) defined on a uniform Monkhorst-Pack mesh of k-points. The vectors \\(\\{{\\bf b}\\}\\) connect each mesh-point \\({\\bf k}\\) to its nearest neighbours. \\(N_{\\mathrm{sh}}\\) shells of neighbours are included in the finite-difference formula, with \\(M_s\\) vectors in the \\(s^{\\mathrm{th}}\\) shell. For \\(\\nabla_{{\\bf k}}\\) to be correct to linear order, we require that the following equation is satisfied (Eq.\u00a0B1 of Ref.\u00a0<sup>1</sup>): \\(\\(\\label{eq:B1} \\sum_{s}^{N_{\\mathrm{sh}}} w_s \\sum_i^{M_{\\mathrm{s}}} b_{\\alpha}^{i,s} b_{\\beta}^{i,s} = \\delta_{\\alpha\\beta}\\:,\\)\\) where \\({\\bf b}^{i,s}\\), \\(i\\in[1,M_s]\\), is the \\(i^{\\mathrm{th}}\\) vector belonging to the \\(s^{\\mathrm{th}}\\) shell with associated weight \\(w_s\\), and \\(\\alpha\\) and \\(\\beta\\) run over the three Cartesian indices.</p>"},{"location":"user_guide/wannier90/parameters/#integer-shell_list","title":"<code>integer :: shell_list(:)</code>","text":"<p><code>shell_list</code> is vector listing the shells to include in the finite difference expression. If this keyword is absent, the shells are chosen automatically.</p>"},{"location":"user_guide/wannier90/parameters/#integer-search_shells","title":"<code>integer :: search_shells</code>","text":"<p>Specifies the number of shells of neighbours over which to search in attempting to determine an automatic solution to the B1 condition Eq.\u00a0[eq:B1]. Larger values than the default may be required in special cases e.g. for very long thin unit cells.</p> <p>The default value is 36.</p>"},{"location":"user_guide/wannier90/parameters/#logical-skip_b1_tests","title":"<code>logical :: skip_B1_tests</code>","text":"<p>If set to <code>.true.</code>, does not check the B1 condition Eq.\u00a0[eq:B1]. This should only be used if one knows why the B1 condition should not be verified. A typical use of this flag is in conjunction with the Z2PACK code: http://www.physics.rutgers.edu/z2pack/.</p> <p>The default value is <code>.false.</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dimension-5-nnkpts","title":"<code>integer, dimension(:, 5) :: nnkpts</code>","text":"<p>Specifies the nearest-neighbour k-points which are written to the <code>.nnkp</code> file. This can be used to explicitly specify which overlap matrices should be calculated.</p> <pre><code>begin nnkpts\n1   2   0  0  0\n.\n.\nend nnkpts\n</code></pre> <p>Each nearest neighbour \\(\\mathbf{k + b}\\) is given by a line of 5 integers. The first specifies the k-point number <code>nkp</code> of \\(\\mathbf{k}\\). The second is the k-point number of the neighbour. The final three integers specify the reciprocal lattice vector which brings the k-point specified by the second integer to \\(\\mathbf{k + b}\\).</p> <p>This format is the same as in the <code>.nnkp</code> file, except that the number of neighbours per k-point is not specified. However, the number of neighbours still needs to be a multiple of the number of k-points.</p> <p>This input parameter can be used only if <code>postproc_setup = .true.</code>, and is not intended to be used with a full Wannier90 run. It can be used also if the k-points do not describe a regular mesh.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-kmesh_tol","title":"<code>real(kind=dp) :: kmesh_tol</code>","text":"<p>Two kpoints belong to the same shell if the distance between them is less than <code>kmesh_tol</code>. Units are Ang.</p> <p>The default value is 0.000001 Ang.</p>"},{"location":"user_guide/wannier90/parameters/#projection","title":"Projection","text":"<p>The projections block defines a set of localised functions used to generate an initial guess for the unitary transformations. This data will be written in the <code>seedname.nnkp</code> file to be used by a first-principles code.</p> <p><code>begin projections</code>\\ .\\ .\\ <code>end projections</code></p> <p>If <code>guiding_centres</code>=<code>true</code>, then the projection centres are used as the guiding centres in the Wannierisation routine.</p> <p>For details see Section\u00a03.1{reference-type=\"ref\" reference=\"sec:proj\"}.</p>"},{"location":"user_guide/wannier90/parameters/#job-control","title":"Job Control","text":""},{"location":"user_guide/wannier90/parameters/#logical-postproc_setup","title":"<code>logical :: postproc_setup</code>","text":"<p>If <code>postproc_setup</code>=<code>true</code>, then the wannier code will write <code>seedname.nnkp</code> file and exit. If <code>wannier90</code>\u00a0is called with the option <code>-pp</code>, then <code>postproc_setup</code> is set to <code>true</code>, over-riding its value in the <code>seedname.win</code> file.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-iprint","title":"<code>integer :: iprint</code>","text":"<p>This indicates the level of verbosity of the output from 0 (\"low\"), the bare minimum, to 3 (\"high\"), which corresponds to full debugging output.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#integer-optimisation","title":"<code>integer :: optimisation</code>","text":"<p>This indicates the level of optimisation used in the code. This is a trade between speed and memory. A positive number indicates fastest execution time at the cost of more memory. Zero or negative numbers indicates a smaller memory footprint - at increased execution time.</p> <p>At the moment the only values that have an effect are <code>optimisation&lt;=0</code> (low memory) and <code>optimisation&gt;0</code> (fast)</p> <p>The default value is 3.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-length_unit","title":"<code>character(len=20) :: length_unit</code>","text":"<p>The length unit to be used for writing quantities in the output file <code>seedname.wout</code>.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>Ang</code> (default)</p> </li> <li> <p><code>Bohr</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen50-devel_flag","title":"<code>character(len=50) :: devel_flag</code>","text":"<p>Not a regular keyword. Its purpose is to allow a developer to pass a string into the code to be used inside a new routine as it is developed.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#integer-exclude_bands","title":"<code>integer :: exclude_bands(:)</code>","text":"<p>A k-point independent list of states to excluded from the calculation of the overlap matrices; for example to select only valence states, or ignore semi-core states. This keyword is passed to the first-principles code via the <code>seedname.nnkp</code> file. For example, to exclude bands 2, 6, 7, 8 and 12:</p> <p><code>exclude_bands : 2, 6-8, 12</code></p>"},{"location":"user_guide/wannier90/parameters/#integer-select_projections","title":"<code>integer :: select_projections(:)</code>","text":"<p>A list of projections to be included in the wannierisation procedure. In the case that <code>num_proj</code> is greater than <code>num_wann</code>, this keyword allows a subset of the projections in the projection matrices to be used. For example, to select the projections given by the indices 2, 6, 7, 8 and 12:</p> <p><code>select_projections : 2, 6-8, 12</code></p>"},{"location":"user_guide/wannier90/parameters/#logical-auto_projections","title":"<code>logical :: auto_projections</code>","text":"<p>If <code>.true.</code> and no projections block is defined, then <code>wannier90</code>\u00a0writes an additional block in the <code>.nnkp</code> file during the pre-processing step, to instruct the interface code to automatically generate the \\(A_{mn}^{(\\mathbf{k})}\\).</p> <p>For additional information on the behavior and on the added block, see Sec.\u00a0[sec:auto-projections-block]{reference-type=\"ref\" reference=\"sec:auto-projections-block\"}.</p> <p>Note: the interface code (e.g. <code>pw2wannier90.x</code>) must have at least one implementation of a method to automatically generate initial projections in order for this option to be usable.</p> <p>The default value of this parameter is \\(\\verb#false#\\).</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-restart","title":"<code>character(len=20) :: restart</code>","text":"<p>If <code>restart</code> is present the code will attempt to restart the calculation from the <code>seedname.chk</code> file. The value of the parameter determines the position of the restart</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>default</code>. Restart from the point at which the check file     <code>seedname.chk</code> was written</p> </li> <li> <p><code>wannierise</code>. Restart from the beginning of the wannierise routine</p> </li> <li> <p><code>plot</code>. Go directly to the plotting phase</p> </li> <li> <p><code>transport</code>. Go directly to the transport routines</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wvfn_formatted","title":"<code>character(len=20) :: wvfn_formatted</code>","text":"<p>If <code>wvfn_formatted</code>=<code>true</code>, then the wavefunctions will be read from disk as formatted (ie ASCII) files; otherwise they will be read as unformatted files. Unformatted is generally preferable as the files will take less disk space and I/O is significantly faster. However such files will not be transferable between all machine architectures and formatted files should be used if transferability is required (i.e., for test cases).</p> <p>The default value of this parameter is \\(\\verb#false#\\).</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-spin","title":"<code>character(len=20) :: spin</code>","text":"<p>For bands from a spin polarised calculation <code>spin</code> determines which set of bands to read in, either <code>up</code> or <code>down</code>.</p> <p>The default value of this parameter is <code>up</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-timing_level","title":"<code>integer :: timing_level</code>","text":"<p>Determines the amount of timing information regarding the calculation that will be written to the output file. A value of 1 produces the least information.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#logical-translate_home_cell","title":"<code>logical :: translate_home_cell</code>","text":"<p>Determines whether to translate the final Wannier centres to the home unit cell at the end of the calculation. Mainly useful for molecular systems in which the molecule resides entirely within the home unit cell and user wants to write an xyz file (<code>write_xyz=.true.</code>) for the WF centres to compare with the structure.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_xyz","title":"<code>logical :: write_xyz</code>","text":"<p>Determines whether to write the atomic positions and final Wannier centres to an xyz file, <code>seedname_centres.xyz</code>, for subsequent visualisation.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_vdw_data","title":"<code>logical :: write_vdw_data</code>","text":"<p>Determines whether to write <code>seedname.vdw</code> for subsequent post-processing by the <code>w90vdw</code> utility (in the <code>utility/w90vdw/</code> directory of the distribution) for calculating van der Waals energies. Brillouin zone sampling must be at the Gamma-point only.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#disentanglement","title":"Disentanglement","text":"<p>These keywords control the disentanglement routine of Ref.\u00a0<sup>3</sup>, i.e., the iterative minimisation of \\(\\Omega_{\\mathrm{I}}\\). This routine will be activated if <code>num_wann</code>\\(\\:&lt;\\:\\)<code>num_bands</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_win_min","title":"<code>real(kind=dp) :: dis_win_min</code>","text":"<p>The lower bound of the outer energy window for the disentanglement procedure. Units are eV.</p> <p>The default is the lowest eigenvalue in the system.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_win_max","title":"<code>real(kind=dp) :: dis_win_max</code>","text":"<p>The upper bound of the outer energy window for the disentanglement procedure. Units are eV.</p> <p>The default is the highest eigenvalue in the given states (i.e., all states are included in the disentanglement procedure).</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_froz_min","title":"<code>real(kind=dp) :: dis_froz_min</code>","text":"<p>The lower bound of the inner energy window for the disentanglement procedure. Units are eV.</p> <p>If <code>dis_froz_max</code> is given, then the default for <code>dis_froz_min</code> is <code>dis_win_min</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_froz_max","title":"<code>real(kind=dp) :: dis_froz_max</code>","text":"<p>The upper bound of the inner (frozen) energy window for the disentanglement procedure. If <code>dis_froz_max</code> is not specified, then there are no frozen states. Units are eV.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#logical-dis_froz_proj","title":"<code>logical :: dis_froz_proj</code>","text":"<p>To activate projectability disentanglement procedure, which selectively discard/disentangle/freeze state \\(\\vert n \\mathbf{k}\\rangle\\) based on its projectability onto some localized atomic orbitals.</p> <p>Note: this requires the <code>amn</code> file is properly normalized, i.e., projectability computed from \\(A A^\\dagger\\) must be smaller than or equal to 1. The pseudo-atomic projection satisfies such requirement, see 3.6.</p> <p>Additionally, one can combine projectability disentanglement with energy disentanglement, i.e., enable both <code>dis_proj_min/max</code> and <code>dis_froz_min/max</code> simultaneously in the <code>win</code> file. These settings will freeze the union of inner energy window and high-projectability states, and exclude the union of states outside outer energy window and having low projectability.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_proj_min","title":"<code>real(kind=dp) :: dis_proj_min</code>","text":"<p>The lower bound for the projectability disentanglement procedure.</p> <p>For states with projectabilities smaller than <code>dis_proj_min</code>, they will be discarded in the disentanglement procedure, i.e., similar to the case of outside of the outer energy window.</p> <p>For states with projectabilities larger than or equal to <code>dis_proj_min</code>, they will be included in the disentanglement procedure, i.e., similar to the case of inside the outer energy window.</p> <p>No unit.</p> <p>The default value is 0.95.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_proj_max","title":"<code>real(kind=dp) :: dis_proj_max</code>","text":"<p>The upper bound for the projectability disentanglement procedure. For states with projectability larger than or equal to <code>dis_proj_max</code>, they will be freezed in the disentanglement procedure, i.e., similar to the case of inside the inner energy window.</p> <p>No unit.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_num_iter","title":"<code>integer :: dis_num_iter</code>","text":"<p>In the disentanglement procedure, the number of iterations used to extract the most connected subspace.</p> <p>The default value is 200.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_mix_ratio","title":"<code>real(kind=dp) :: dis_mix_ratio</code>","text":"<p>In the disentanglement procedure, the mixing parameter to use for convergence (see pages 4-5 of Ref.\u00a0<sup>3</sup>). A value of 0.5 is a 'safe' choice. Using 1.0 (i.e., no mixing) often gives faster convergence, but may cause the minimisation of \\(\\Omega_{\\mathrm{I}}\\) to be unstable in some cases.</p> <p>Restriction: \\(0.0&lt;\\:\\)<code>dis_mix_ratio</code>\\(\\:\\leq 1.0\\)</p> <p>The default value is 0.5</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_conv_tol","title":"<code>real(kind=dp) :: dis_conv_tol</code>","text":"<p>In the disentanglement procedure, the minimisation of \\(\\Omega_{\\mathrm{I}}\\) is said to be converged if the fractional change in the gauge-invariant spread between successive iterations is less than <code>dis_conv_tol</code> for <code>dis_conv_window</code> iterations. Units are \u00c5\\(^2\\).</p> <p>The default value is 1.0E-10</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_conv_window","title":"<code>integer :: dis_conv_window</code>","text":"<p>In the disentanglement procedure, the minimisation is said to be converged if the fractional change in the spread between successive iterations is less than <code>dis_conv_tol</code> for <code>dis_conv_window</code> iterations.</p> <p>The default value of this parameter is 3.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_spheres_num","title":"<code>integer :: dis_spheres_num</code>","text":"<p>Number of spheres in reciprocal space where the k-dependent disentanglement is performed. No disentanglement is performed for those k-points that are not included in any of the spheres.</p> <p>The default is 0, which means disentangle at every k-point in the full BZ (the standard mode in Wannier90).</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_spheres_first_wann","title":"<code>integer :: dis_spheres_first_wann</code>","text":"<p>Index of the first band that has to be considered as a Wannier function. Used only if <code>dis_spheres_num</code> is greater than zero. At k-points where disentanglement is not performed the bands from <code>dis_spheres_first_wann</code> to <code>dis_spheres_first_wann+num_wann</code> are used to wannierise. The bands excluded using <code>exclude_bands</code> should not be counted.</p> <p>The default is 1, the band at the lowest energy.</p>"},{"location":"user_guide/wannier90/parameters/#dis_spheres","title":"dis_spheres","text":"<p>Each line gives the coordinate \\(\\mathbf{K}=K_1 \\mathbf{B}_{1} + K_2 \\mathbf{B}_{2} + K_3 \\mathbf{B}_3\\) of a k-point representing the center of one of the spheres used for k-dependent disentanglement. The same crystallographic units as for <code>kpoints</code> are used here. Each k-point coordinate \\(\\mathbf{K}^i\\) must the followed by the respectice sphere radius \\(r_{i}\\) in inverse angstrom (on the same line).</p> <p>The number of lines must be equal to <code>dis_spheres_num</code>.</p> <p><code>begin dis_spheres</code> \\(\\(\\begin{array}{cccc}  K^{1}_{1} &amp; K^{1}_{2} &amp; K^{1}_{3} &amp; r_{1} \\\\  K^{2}_{1} &amp; K^{2}_{2} &amp; K^{2}_{3} &amp; r_{2} \\\\ \\vdots \\end{array}\\)\\) <code>end dis_spheres</code></p> <p>There is no default.</p>"},{"location":"user_guide/wannier90/parameters/#wannierise","title":"Wannierise","text":"<p>Iterative minimisation of \\(\\widetilde{\\Omega}\\), the non-gauge-invariant part of the spread functional.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_iter","title":"<code>integer :: num_iter</code>","text":"<p>Total number of iterations in the minimisation procedure. Set <code>num_iter=0</code> if you wish to generate projected WFs rather than maximally-localized WFs (see Example\u00a08 in the Tutorial).</p> <p>The default value is 100</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_cg_steps","title":"<code>integer :: num_cg_steps</code>","text":"<p>Number of conjugate gradient steps to take before resetting to steepest descents.</p> <p>The default value is 5</p>"},{"location":"user_guide/wannier90/parameters/#integer-conv_window","title":"<code>integer :: conv_window</code>","text":"<p>If <code>conv_window</code>\\(\\:&gt;1\\), then the minimisation is said to be converged if the change in \\(\\Omega\\) over <code>conv_window</code> successive iterations is less than <code>conv_tol</code>. Otherwise, the minimisation proceeds for num_iter iterations (default).</p> <p>The default value is -1</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-conv_tol","title":"<code>real(kind=dp) :: conv_tol</code>","text":"<p>If <code>conv_window</code>\\(\\:&gt;1\\), then this is the convergence tolerance on \\(\\Omega\\), otherwise not used. Units are \u00c5\\(^2\\).</p> <p>The default value is 1.0E-10</p>"},{"location":"user_guide/wannier90/parameters/#logical-precond","title":"<code>logical :: precond</code>","text":"<p>Whether or not to use preconditioning to speed up the minimization of the spreads. This is based on the same idea as the classical Tetter-Payne-Allan preconditionning for DFT and dampens the high-frequency oscillations of the gradient due to contributions from large real lattice vectors. It is useful when the optimization is slow, especially on fine grids. When <code>optimisation&lt;3</code>, this uses a slower algorithm to save memory.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-conv_noise_amp","title":"<code>real(kind=dp) :: conv_noise_amp</code>","text":"<p>If <code>conv_noise_amp</code>\\(\\:&gt;0\\), once convergence (as defined above) is achieved, some random noise \\(f\\) is added to the search direction, and the minimisation is continued until convergence is achieved once more. If the same value of \\(\\Omega\\) as before is arrived at, then the calculation is considered to be converged. If not, then random noise is added again and the procedure repeated up to a maximum of <code>conv_noise_num</code> times. <code>conv_noise_amp</code> is the amplitude of the random noise \\(f\\) that is added to the search direction: \\(0 &lt; |f| &lt;\\:\\)<code>conv_noise_amp</code>. This functionality requires <code>conv_window</code>\\(\\:&gt;1\\). If <code>conv_window</code> is not specified, it is set to the value 5 by default.</p> <p>If <code>conv_noise_amp</code>\\(\\:\\leq 0\\), then no noise is added (default).</p> <p>The default value is -1.0</p>"},{"location":"user_guide/wannier90/parameters/#integer-conv_noise_num","title":"<code>integer :: conv_noise_num</code>","text":"<p>If <code>conv_noise_amp</code>\\(\\:&gt;0\\), then this is the number of times in the minimisation that random noise is added.</p> <p>The default value is 3</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_dump_cycles","title":"<code>integer :: num_dump_cycles</code>","text":"<p>Write sufficient information to do a restart every <code>num_dump_cycles</code> iterations.</p> <p>The default is 100</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_print_cycles","title":"<code>integer :: num_print_cycles</code>","text":"<p>Write data to the master output file <code>seedname.wout</code> every <code>num_print_cycles</code> iterations.</p> <p>The default is 1</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_r2mn","title":"<code>logical :: write_r2mn</code>","text":"<p>If \\(\\verb#write_r2mn#=\\verb#true#\\), then the matrix elements \\(\\langle m|r^2|n\\rangle\\) (where \\(m\\) and \\(n\\) refer to WF) are written to file <code>seedname.r2mn</code> at the end of the Wannierisation procedure.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-guiding_centres","title":"<code>logical :: guiding_centres</code>","text":"<p>Use guiding centres during the minimisation, in order to avoid local minima.</p> <p><code>wannier90</code>\u00a0uses a logarithm definition of the spread functional. As we are taking the log of a complex argument there is a possibility that the algorithm might make inconsistent choices for the branch cut. This manifests itself as complex WF with a large spread. By using guiding centres the code will attempt to make a consistent choice of branch cut. Experience shows that with <code>guiding_centres</code> set to true this problem is avoided and doing so does not cause any problems. For this reason we recommend setting <code>guiding_centres</code> to true where possible (it is only not possible if an explicit projection block is not defined).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_guide_cycles","title":"<code>integer :: num_guide_cycles</code>","text":"<p>If <code>guiding_centres</code> is set to true, then the guiding centres are used only every <code>num_guide_cycles</code>.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_no_guide_iter","title":"<code>integer :: num_no_guide_iter</code>","text":"<p>If <code>guiding_centres</code> is set to true, then the guiding centres are used only after <code>num_no_guide_iter</code> minimisation iterations have been completed.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-trial_step","title":"<code>real(kind=dp) :: trial_step</code>","text":"<p>The value of the trial step for the parabolic fit in the line search minimisation used in the minimisation of the spread function. Cannot be used in conjunction with <code>fixed_step</code> (see below). If the minimisation procedure doesn't converge, try decreasing the value of <code>trial_step</code> to give a more accurate line search.</p> <p>The default value is 2.0</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fixed_step","title":"<code>real(kind=dp) :: fixed_step</code>","text":"<p>If this is given a value in the input file, then a fixed step of length <code>fixed_step</code> (instead of a parabolic line search) is used at each iteration of the spread function minimisation. Cannot be used in conjunction with <code>trial_step</code>. This can be useful in cases in which minimisation with a line search fails to converge.</p> <p>There is no default value.</p>"},{"location":"user_guide/wannier90/parameters/#logical-use_bloch_phases","title":"<code>logical :: use_bloch_phases</code>","text":"<p>Determines whether to use the Bloch functions as the initial guess for the projections. Can only be used if <code>disentanglement = false</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-site_symmetry","title":"<code>logical :: site_symmetry</code>","text":"<p>Construct symmetry-adapted Wannier functions. For the detail of the theoretical background, see Ref.\u00a0<sup>4</sup>. Cannot be used in conjunction with the inner (frozen) energy window.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-symmetrize_eps","title":"<code>real(kind=dp) :: symmetrize_eps</code>","text":"<p>Convergence threshold to check whether the symmetry condition (Eq. (19) in Ref.\u00a0<sup>4</sup>) on the unitary matrix \\(\\mathbf{U}^{(\\mathbf{k})}\\) is satisfied or not. See also Eq. (29) in Ref.\u00a0<sup>4</sup>. Used when <code>site_symmetry = .true</code>.</p> <p>The default value is 1.0E-3.</p>"},{"location":"user_guide/wannier90/parameters/#integer-slwf_num","title":"<code>integer :: slwf_num</code>","text":"<p>The number of objective Wannier functions for selective localisation in the selectively localised Wannier function (SLWF) method of Ref.\u00a0<sup>5</sup>. These functions are obtained by minimising the spread functional only with respect to the degrees of freedom of a subset of <code>slwf_num</code> \\(&lt;\\) <code>num_wann</code> functions. At convergence, the objective WFs will have a minimum cumulative spread, whereas the remaining <code>num_wann</code> \\(-\\) <code>slwf_num</code> functions are left unoptimised. The initial guesses for the objective WFs are given by the first <code>slwf_num</code> orbitals in the <code>projections</code> block. If <code>slwf_num = num_wann</code> no selective minimisation is performed. In this case, <code>wannier90</code>\u00a0will simply generate a set of <code>num_wann</code> MLWFs.</p> <p>The default is <code>num_wann</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-slwf_constrain","title":"<code>logical :: slwf_constrain</code>","text":"<p>If <code>slwf_constrain=true</code>, then the centres of the objective Wannier functions are constrained to either the centres of the first <code>slwf_num</code> orbitals in the <code>projections</code> block or to new positions specified in the <code>slwf_centres</code> block (see Sec.\u00a02.8.22{reference-type=\"ref\" reference=\"sec:centre_constraints\"}). In this case, a modified spread functional, \\(\\Omega_c\\), with the addition of a constraint term, as described in Ref.\u00a0<sup>5</sup>.</p> <p>The default is <code>false</code></p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-slwf_lambda","title":"<code>real(kind=dp) :: slwf_lambda</code>","text":"<p>The value of the Lagrange multiplier \\(\\lambda\\) for the constraint term in term added to modify the spread functional: \\(\\lambda \\sum_{n=1}^{J'} \\left(\\overline{\\mathbf{r}}_n - \\mathbf{r}_{0n}\\right)^2\\), where \\(J'\\) is <code>slwf_num</code>, and \\(\\overline{\\mathbf{r}}_{n}\\) and \\(\\mathbf{r}_{0n}\\) are the centre and target centre, respectively, for the \\(n^{\\text{th}}\\) objective WF.</p> <p>The default is <code>0.0</code>.</p>"},{"location":"user_guide/wannier90/parameters/#sec:centre_constraints","title":"Constraints on centres","text":"<p>If <code>slwf_constrain=true</code>, then by default the centres to which the <code>slwf_num</code> objective Wannier function centres are constrained are given by the first <code>slwf_num</code> rows of the <code>projections</code> block.</p> <p>Optionally, the <code>slwf_centres</code> block may be used to define alternative target centres for some or all of the <code>slwf_num</code> objective Wannier functions.</p> <p>The block below shows an example of how to set the constraints:</p> <p><code>begin slwf_centres</code>\\ <code>2  0.0   0.0  0.0</code>\\ <code>4  0.25  0.0  0.0</code>\\ <code>end slwf_centres</code></p> <ul> <li> <p>The first line sets the constraint for the centre of objective WF     number 2 (as defined by the order of WFs in the <code>projections</code> block)     to (0.0,0.0,0.0) in fractional co-ordinates.</p> </li> <li> <p>The second line sets the constraint for the centre of objective WF     number 4 (as defined by the order of WFs in the <code>projections</code> block)     to (0.25,0.0,0.0) in fractional co-ordinates.</p> </li> <li> <p>The target centres of all other objective Wannier functions remain     as the centres given in the corresponding rows of the <code>projections</code>     block.</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#post-processing","title":"Post-Processing","text":"<p>Capabilities:</p> <ul> <li> <p>Plot the WF</p> </li> <li> <p>Plot the interpolated band structure</p> </li> <li> <p>Plot the Fermi surface</p> </li> <li> <p>Output the Hamiltonian in the WF basis</p> </li> <li> <p>Transport calculation (quantum conductance and density of states)</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-wannier_plot","title":"<code>logical :: wannier_plot</code>","text":"<p>If \\(\\verb#wannier_plot#=\\verb#true#\\), then the code will write out the Wannier functions in a format specified by <code>wannier_plot_format</code></p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-wannier_plot_list","title":"<code>integer :: wannier_plot_list(:)</code>","text":"<p>A list of WF to plot. The WF numbered as per the <code>seedname.wout</code> file after the minimisation of the spread.</p> <p>The default behaviour is to plot all WF. For example, to plot WF 4, 5, 6 and 10:</p> <p><code>wannier_plot_list : 4-6, 10</code></p>"},{"location":"user_guide/wannier90/parameters/#integer-wannier_plot_supercell","title":"<code>integer :: wannier_plot_supercell</code>","text":"<p>The code generates the WFs on a grid corresponding to a 'super-unit-cell'. If <code>wannier_plot_supercell</code> is provided as a single integer, then the size of the super-unit-cell is <code>wannier_plot_supercell</code> times the size of the unit cell along all three linear dimensions (the 'home' unit cell is kept approximately in the middle); otherwise, if three integers are provided, the size of the super-unit-cell is <code>wannier_plot_supercell(i)</code> times the size of the unit cell along the \\(i-\\)th linear dimension.</p> <p>The default value is 2.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_format","title":"<code>character(len=20) :: wannier_plot_format</code>","text":"<p>WF can be plotted in either XCrySDen (xsf) format or Gaussian cube format. The valid options for this parameter are:</p> <ul> <li> <p><code>xcrysden</code> (default)</p> </li> <li> <p><code>cube</code></p> </li> </ul> <p>If <code>wannier_plot_format=xsf</code>: the code outputs the WF on the entire super-unit-cell specified by <code>wannier_plot_supercell</code>.</p> <p>If <code>wannier_plot_format=cube</code>: the code outputs the WF on a grid that is smaller than the super-unit-cell specified by <code>wannier_plot_supercell</code>. This grid is determined by <code>wannier_plot_mode</code>, <code>wannier_plot_radius</code> and <code>wannier_plot_scale</code>, described in detail below.</p> <p>The code is able to output Gaussian cube files for systems with non-orthogonal lattice vectors. Many visualisation programs (including XCrySDen), however, are only able to handle cube files for systems with orthogonal lattice vectors. One visualisation program that is capable of dealing with non-orthogonal lattice vectors is VESTA (http://jp-minerals.org/vesta/en/).</p> <p>Note</p> <p>It's worth noting that another visualisation program, VMD (http://www.ks.uiuc.edu/Research/vmd), is able to deal with certain special cases of non-orthogonal lattice vectors; see http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html for details.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_mode","title":"<code>character(len=20) :: wannier_plot_mode</code>","text":"<p>Choose the mode in which to plot the WF, either as a molecule or as a crystal.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>crystal</code> (default)</p> </li> <li> <p><code>molecule</code></p> </li> </ul> <p>If <code>wannier_plot_format=cube</code>:</p> <ul> <li> <p>if <code>wannier_plot_mode = molecule</code>, then wherever the WF centre sits     in the supercell, the origin of the cube is shifted (for the purpose     of plotting only, ie, nothing is done to the U matrices etc) to     coincide with the centre of mass of the atomic positions specified     by the user in the <code>.win</code> input file. These atomic positions are     also written to the cube file, so when it is visualised, the WF     appears superimposed on the molecular structure.</p> </li> <li> <p>if <code>wannier_plot_mode = crystal</code>, then the WF is not shifted, but     instead the code searches for atoms that are within a radius of     <code>wannier_plot_scale</code> \\(\\times\\) <code>wannier_plot_radius</code> of the WF centre     and writes the coordinates of these atoms to the cube file. In this     way, when the cube file is visualised, the WF appears superimposed     on the nearest atoms to the WF centre.</p> </li> <li> <p><code>crystal</code> mode can be used for molecules, and <code>molecule</code> mode can be     used for crystals.</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#realkinddp-wannier_plot_radius","title":"<code>real(kind=dp) :: wannier_plot_radius</code>","text":"<p>If <code>wannier_plot_format=cube</code>, then <code>wannier_plot_radius</code> is the radius of the sphere that must fit inside the parallelepiped in which the WF is plotted. <code>wannier_plot_radius</code> must be greater than 0. Units are \u00c5.</p> <p>The default value is 3.5.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-wannier_plot_scale","title":"<code>real(kind=dp) :: wannier_plot_scale</code>","text":"<p>If <code>wannier_plot_format=cube</code> and <code>wannier_plot_mode=crystal</code>, then the code searches for atoms that are within a radius of <code>wannier_plot_scale</code> \\(\\times\\) <code>wannier_plot_radius</code> of the WF centre and writes the coordinates of these atoms to the cube file. In this way, when the cube file is visualised, the WF appears superimposed on the nearest atoms to the WF centre. <code>wannier_plot_scale</code> must be greater than 0. This parameter is dimensionless.</p> <p>The default value is 1.0.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_spinor_mode","title":"<code>character(len=20) :: wannier_plot_spinor_mode</code>","text":"<p>If \\(\\verb#spinors#=\\verb#true#\\) then this parameter controls the quantity to plot. For a spinor WF with components \\([\\phi,\\psi]\\) the quatity plotted is</p> <ul> <li> <p><code>total</code> (default). \\(\\sqrt{[|\\phi|^2+|\\psi|^2}\\)</p> </li> <li> <p><code>up</code>. \\(|\\phi|\\times sign(Re\\{\\phi\\})\\) if     \\(\\verb#wannier_plot_spinor_phase#=\\verb#true#\\), otherwise \\(|\\phi|\\)</p> </li> <li> <p><code>down</code>. \\(|\\psi|\\times sign(Re\\{\\psi\\})\\) if     \\(\\verb#wannier_plot_spinor_phase#=\\verb#true#\\), otherwise \\(|\\psi|\\)</p> </li> </ul> <p>Note: making a visual representation of a spinor WF is not as straightforward as for a scalar WF. While a scalar WF is typically a real valued function, a spinor WF is a complex, two component spinor. <code>wannier90</code>\u00a0is able to plot several different quantities derived from a spinor WF which should give you a good idea of the nature of the WF.</p>"},{"location":"user_guide/wannier90/parameters/#logical-wannier_plot_spinor_phase","title":"<code>logical :: wannier_plot_spinor_phase</code>","text":"<p>If \\(\\verb#wannier_plot_spinor_phase#=\\verb#true#\\) phase information will be taken into account when plotting a spinor WF.</p>"},{"location":"user_guide/wannier90/parameters/#logical-bands_plot","title":"<code>logical :: bands_plot</code>","text":"<p>If \\(\\verb#bands_plot#=\\verb#true#\\), then the code will calculate the band structure, through Wannier interpolation, along the path in k-space defined by <code>bands_kpath</code> using <code>bands_num_points</code> along the first section of the path and write out an output file in a format specified by <code>bands_plot_format</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#kpoint_path","title":"kpoint_path","text":"<p>Defines the path in k-space along which to calculate the bandstructure. Each line gives the start and end point (with labels) for a section of the path. Values are in fractional coordinates with respect to the primitive reciprocal lattice vectors.</p> <p><code>begin kpoint_path</code> \\(\\(\\begin{array}{cccccccc} G &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; L &amp; 0.0 &amp; 0.0 &amp; 1.0 \\\\ L &amp; 0.0 &amp; 0.0 &amp; 1.0 &amp; N &amp; 0.0 &amp; 1.0 &amp; 1.0 \\\\ \\vdots \\end{array}\\)\\) <code>end kpoint_path</code></p> <p>There is no default</p>"},{"location":"user_guide/wannier90/parameters/#integer-bands_num_points","title":"<code>integer :: bands_num_points</code>","text":"<p>If \\(\\verb#bands_plot#=\\verb#true#\\), then the number of points along the first section of the bandstructure plot given by <code>kpoint_path</code>. Other sections will have the same density of k-points.</p> <p>The default value for <code>bands_num_points</code> is 100.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-bands_plot_format","title":"<code>character(len=20) :: bands_plot_format</code>","text":"<p>Format in which to plot the interpolated band structure. The valid options for this parameter are:</p> <ul> <li> <p><code>gnuplot</code> (default)</p> </li> <li> <p><code>xmgrace</code></p> </li> </ul> <p>Note: it is possible to request output in both formats eg \\(\\verb#bands_format#=\\verb#gnuplot xmgrace#\\)</p>"},{"location":"user_guide/wannier90/parameters/#integer-bands_plot_project","title":"<code>integer :: bands_plot_project(:)</code>","text":"<p>If present <code>wannier90</code>\u00a0will compute the contribution of this set of WF to the states at each point of the interpolated band structure. The WF are numbered according to the seedname.wout file. The result is written in the <code>seedname_band.dat</code> file, and a corresponding gnuplot script to <code>seedname_band_proj.dat</code> .</p> <p>For example, to project on to WFs 2, 6, 7, 8 and 12:</p> <p><code>bands_plot_project : 2, 6-8, 12</code></p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-bands_plot_mode","title":"<code>character(len=20) :: bands_plot_mode</code>","text":"<p>To interpolate the band structure along the k-point path, either use the Slater-Koster interpolation scheme or truncate the Hamiltonian matrix in the WF basis. Truncation criteria are provided by <code>hr_cutoff</code> and <code>dist_cutoff</code>.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>s-k</code> (default)</p> </li> <li> <p><code>cut</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#integer-bands_plot_dim","title":"<code>integer :: bands_plot_dim</code>","text":"<p>Dimension of the system. If \\(\\verb#bands_plot_dim#&lt;\\:\\)<code>&lt;!-- --&gt;</code>3 and \\(\\verb#bands_plot_mode#=\\verb#cut#\\), lattice vector \\(\\mathbf{R}=N_1 \\mathbf{A}_{1} + N_2 \\mathbf{A}_{2} + N_3 \\mathbf{A}_3\\), where \\(N_i=0\\) if \\(\\mathbf{A}_i\\) is parallel to any of the confined directions specified by <code>one_dim_axis</code>, are exclusively used in the band structure interpolation.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p>3 (default)</p> </li> <li> <p>2</p> </li> <li> <p>1</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-fermi_surface_plot","title":"<code>logical :: fermi_surface_plot</code>","text":"<p>If \\(\\verb#fermi_surface_plot#=\\verb#true#\\), then the code will calculate, through Wannier interpolation, the eigenvalues on a regular grid with <code>fermi_surface_num_points</code> in each direction. The code will write a file in bxsf format which can be read by XCrySDen in order to plot the Fermi surface.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-fermi_surface_num_points","title":"<code>integer :: fermi_surface_num_points</code>","text":"<p>If \\(\\verb#fermi_surface_plot#=\\verb#true#\\), then the number of divisions in the regular k-point grid used to calculate the Fermi surface.</p> <p>The default value for <code>fermi_surface_num_points</code> is 50.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy","title":"<code>real(kind=dp) :: fermi_energy</code>","text":"<p>The Fermi energy in eV. This parameter is written into the bxsf file. If <code>fermi_energy</code> is specified, <code>fermi_energy_min</code>, <code>fermi_energy_max</code>, and <code>fermi_energy_step</code> should not be specified, and vice-versa.</p> <p>The default value is 0.0</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_min","title":"<code>real(kind=dp) :: fermi_energy_min</code>","text":"<p>Instead of specifyfing a single Fermi energy, it is possible to scan the Fermi level over a range of values, and recompute certain quantities for each \\(\\varepsilon_F\\). This is the minimum value in the range (in eV).</p> <p>Note</p> <p>Scanning the Fermi level is currently supported only by the <code>postw90</code> module <code>berry</code>, for <code>berry_task=ahc,morb</code>. For all other functionalities that require a knowledge of \\(\\varepsilon_F\\), use <code>fermi_energy</code> instead.</p> <p>There is no default value.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_max","title":"<code>real(kind=dp) :: fermi_energy_max</code>","text":"<p>The maximum value in the range of Fermi energies. Units are eV.</p> <p>The default value is <code>fermi_energy_min</code>+1.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_step","title":"<code>real(kind=dp) :: fermi_energy_step</code>","text":"<p>Difference between consecutive values of the Fermi energy when scanning from <code>fermi_energy_min</code> to <code>fermi_energy_max</code>. Units are eV.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-fermi_surface_plot_format","title":"<code>character(len=20) :: fermi_surface_plot_format</code>","text":"<p>Format in which to plot the Fermi surface. The valid options for this parameter are:</p> <ul> <li><code>xcrysden</code> (default)</li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-write_hr","title":"<code>logical :: write_hr</code>","text":"<p>If \\(\\verb#write_hr#=\\verb#true#\\), then the Hamiltonian matrix in the WF basis will be written to a file <code>seedname_hr.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_rmn","title":"<code>logical :: write_rmn</code>","text":"<p>If \\(\\verb#write_rmn#=\\verb#true#\\), then the position operator in the WF basis will be written to a file <code>seedname_r.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_bvec","title":"<code>logical :: write_bvec</code>","text":"<p>If \\(\\verb#write_bvec#=\\verb#true#\\), then the the matrix elements of bvector and their weights will be written to a file <code>seedname.bvec</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_tb","title":"<code>logical :: write_tb</code>","text":"<p>If \\(\\verb#write_tb#=\\verb#true#\\), then the lattice vectors, together with the Hamiltonian and position-operator matrices in the WF basis, will be written to a file <code>seedname_tb.dat</code>, in units of Angstrom and eV.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-transport","title":"<code>logical :: transport</code>","text":"<p>If \\(\\verb#transport#=\\verb#true#\\), then the code will calculate quantum conductance and density of states of a one-dimensional system. The results will be written to files <code>seedname_qc.dat</code> and <code>seedname_dos.dat</code>, respectively. Since both quantities are a function of energy, they will be evaluated from <code>tran_win_min</code> to <code>tran_win_max</code> with an interval of <code>tran_energy_step</code>.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-transport_mode","title":"<code>character(len=20) :: transport_mode</code>","text":"<p>If \\(\\verb#transport_mode#=\\verb#bulk#\\), quantum conductance and density of states are calculated for a perfectly-periodic one-dimensional system. In this case, the transport part can either use the Hamiltonian matrix in the WF basis generated by <code>wannier90</code>\u00a0or a Hamiltonian matrix provided by the external file <code>seedname_htB.dat</code>.</p> <p>If \\(\\verb#transport_mode#=\\verb#lcr#\\), quantum conductance and density of states are calculated for a system where semi-infinite, left and right leads are connected through a central conductor region. In this case, the transport part will work independently from the disentanglement and wannierise procedure. Details of the method is described in Ref. <sup>6</sup>.</p> <p>If \\(\\verb#tran_read_ht# = \\verb#true#\\) then the Hamiltonian matrices must be provided by the five external files: <code>seedname_htL.dat, seedname_htLC.dat, seedname_htC.dat, seedname_htCR.dat, seedname_htR.dat</code>. If \\(\\verb#tran_read_ht# = \\verb#false#\\) then the Hamiltonian matrices are found automatically provided the supercell adheres to conditions outlined in Section\u00a07.3{reference-type=\"ref\" reference=\"sec:2c2\"}.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>bulk</code> (default)</p> </li> <li> <p><code>lcr</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_win_min","title":"<code>real(kind=dp) :: tran_win_min</code>","text":"<p>The lower bound of the energy window for the transport calculation. Units are eV.</p> <p>The default value is -3.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_win_max","title":"<code>real(kind=dp) :: tran_win_max</code>","text":"<p>The upper bound of the energy window for the transport calculation. Units are eV.</p> <p>The default value is 3.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_energy_step","title":"<code>real(kind=dp) :: tran_energy_step</code>","text":"<p>Sampling interval of the energy values from <code>tran_win_min</code> to <code>tran_win_max</code>. Units are eV.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_1","title":"<code>real(kind=dp) :: fermi_energy</code>","text":"<p>The Fermi energy in eV. The energy axis of the quantum conductance and density of states data will be shifted rigidly by this amount.</p> <p>The default value is 0.0</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_bb","title":"<code>integer :: tran_num_bb</code>","text":"<p>Size of a bulk Hamiltonian matrix. This number is equal to the number of WFs in one principal layer.</p> <p>A one-dimensional system can be viewed as an array of principal layers which are defined in a way that localized basis functions inside a certain principal layer only interact with those in the nearest neighbor principal layer. In <code>wannier90</code>\u00a0a principal layer will be an integer multiple of a unit cell, and the size is determined by <code>hr_cutoff</code> and/or <code>dist_cutoff</code>. The criterion is rather arbitrary when WFs are adopted as a localized basis set, and it is up to a user's choice.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_ll","title":"<code>integer :: tran_num_ll</code>","text":"<p>Size of a left-lead Hamiltonian matrix. If \\(\\verb#transport_mode# = \\verb#lcr#\\) and \\(\\verb#tran_read_ht# = \\verb#false#\\) then <code>tran_num_ll</code> is the number of Wannier functions in a principal layer.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_rr","title":"<code>integer :: tran_num_rr</code>","text":"<p>Size of a right-lead Hamiltonian matrix.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cc","title":"<code>integer :: tran_num_cc</code>","text":"<p>Size of a conductor Hamiltonian matrix.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_lc","title":"<code>integer :: tran_num_lc</code>","text":"<p>Number of columns in a left-lead_conductor Hamiltonian matrix. Number of rows must be equal to <code>tran_num_ll</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cr","title":"<code>integer :: tran_num_cr</code>","text":"<p>Number of rows in a conductor_right-lead Hamiltonian matrix. Number of columns must be equal to <code>tran_num_rr</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cell_ll","title":"<code>integer :: tran_num_cell_ll</code>","text":"<p>Number of unit cells in one principal layer of left lead. Used if \\(\\verb#transport_mode# = \\verb#lcr#\\) and \\(\\verb#tran_read_ht# = \\verb#false#\\).</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cell_rr","title":"<code>integer :: tran_num_cell_rr</code>","text":"<p>Number of unit cells in one principal layer of right lead. Not used at present.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_bandc","title":"<code>integer :: tran_num_bandc</code>","text":"<p>Half-bandwidth+1 of a band-diagonal conductor Hamiltonian matrix.</p> <p>The Hamiltonian matrix of a central conductor part, which is read from <code>seedname_htC.dat</code>, will be diagonally dominant when <code>tran_num_cc</code> is very large. <code>tran_num_bandc</code> is used to construct a compact matrix which contains the non-zero band-diagonal part of a full conductor Hamiltonian matrix. Setting this parameter is only meaningful when <code>tran_num_bandc</code> is greater than <code>tran_num_lc</code> and <code>tran_num_cr</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_write_ht","title":"<code>logical :: tran_write_ht</code>","text":"<p>If \\(\\verb#tran_write_ht#=\\verb#true#\\), then the Hamiltonian matrix formatted for the transport calculation will be written to a file <code>seedname_htB.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_read_ht","title":"<code>logical :: tran_read_ht</code>","text":"<p>If \\(\\verb#tran_write_ht#=\\verb#true#\\), then the Hamiltonian matrix formatted for the transport calculation will be read from a set of files described in the parameter <code>transport_mode</code>. Set \\(\\verb#tran_write_ht#=\\verb#false#\\) to perform automated lcr calculations (see Section\u00a07.3{reference-type=\"ref\" reference=\"sec:2c2\"}).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_use_same_lead","title":"<code>logical :: tran_use_same_lead</code>","text":"<p>If \\(\\verb#tran_use_same_lead#=\\verb#true#\\), then the left and the right leads are the same. In this case, <code>seedname_htR.dat</code> is not required.</p> <p>The default value is <code>true</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_group_threshold","title":"<code>real(kind=dp) :: tran_group_threshold</code>","text":"<p>Used to group and sort Wannier functions according to the positions of their centres. Wannier functions in a group are within <code>tran_group_threshold</code> from one another in <code>x,y</code> and <code>z</code> directions. Units are \u00c5</p> <p>The default is 0.15</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-translation_centre_frac3","title":"<code>real(kind=dp) :: translation_centre_frac(3)</code>","text":"<p>Centre of the unit cell to which the final Wannier centres are translated. Numbers are in fractional coordinates with respect to the lattice vectors.</p> <p>The default value is (0.0,0.0,0.0).</p>"},{"location":"user_guide/wannier90/parameters/#logical-use_ws_distance","title":"<code>logical :: use_ws_distance</code>","text":"<p>Improves the interpolation of the k-space Hamiltonian, by applying a translation to each WF by a basis vector of the super-lattice that minimises the distance between their centres. The translation is dependent on both WF and on the unit cell vector to which they belong, i.e., translate function \\(W_j({\\bf r}-{\\bf R})\\) inside the Wigner-Seitz cell centred on WF \\(W_i({\\bf r})\\).</p> <p>For a longer explanation, see Chapter\u00a0[chap:interpolation]{reference-type=\"ref\" reference=\"chap:interpolation\"}.</p> <p>If <code>false</code> the code puts all the WF in the home cell, only possible choice until wannier90 v2.0.1.</p> <p>The default value is <code>true</code> (default changed since v.3.0). Introduced in v2.1.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-ws_distance_tol","title":"<code>real(kind=dp) :: ws_distance_tol</code>","text":"<p>Tolerance when determining whether two values \\(\\|\\mathbf{d}_{ij\\mathbf{R}} + \\tilde{\\mathbf{R}}_{nml} \\|\\) and \\(\\|\\mathbf{d}_{ij\\mathbf{R}} + \\tilde{\\mathbf{R}}_{n'm'l'} \\|\\) (as defined in chapter\u00a0[chap:interpolation]{reference-type=\"ref\" reference=\"chap:interpolation\"}) for the shortest distance between two Wannier functions are equivalent. If the difference in distance (in Angstrom) is less than <code>ws_distance_tol</code>, they are taken to be equivalent.</p> <p>The default value is \\(10^{-5}\\).</p>"},{"location":"user_guide/wannier90/parameters/#ws_search_size","title":"<code>:: ws_search_size</code>","text":"<p>Maximum absolute value for the integers \\(n,m,l\\) that identify the super-lattice vectors \\(\\tilde{\\mathbf{R}}_{nml}\\) (see chapter\u00a0[chap:interpolation]{reference-type=\"ref\" reference=\"chap:interpolation\"}) when searching for points inside the Wigner-Seitz cell. If <code>ws_search_size</code> is provided as a single integer, then the number of repetitions of the Born-von Karman cell is the same along all three linear dimensions; otherwise, if three integers are provided, the number of repetitions along the \\(i-\\)th linear dimension is <code>ws_search_size(i)</code>. The variable is used both in <code>hamiltonian.F90</code> and in <code>ws_distance.F90</code>. In the latter case, its value is incremented by one in order to account for WFs whose centre wanders away from the original reference unit cell.\\ The default value is generally sufficient, but might need to be increased in case of elongated cells.</p> <p>The default value is 2.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_u_matrices","title":"<code>logical :: write_u_matrices</code>","text":"<p>Write the \\(\\mathbf{U}^{(\\mathbf{k})}\\) and \\(\\mathbf{U}^{\\mathrm{dis}(\\mathbf{k})}\\) matrices obtained at the end of wannierization to files <code>seedname_u.mat</code> and <code>seedname_u_dis.mat</code>, respectively.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-hr_cutoff","title":"<code>real(kind=dp) :: hr_cutoff</code>","text":"<p>The absolute value of the smallest matrix element of the Hamiltonian in the WF basis. If \\(h_{mn}(\\mathbf{R})&gt;\\:\\)<code>hr_cutoff</code>, then the matrix element \\(h_{mn}(\\mathbf{R})\\) is retained and used in the band structure interpolation (when \\(\\verb#bands_plot_mode#=\\verb#cut#\\)) or in the transport calculation. Otherwise it is deemed to be insignificant and is discarded. Units are eV.</p> <p>The default value is 0.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dist_cutoff","title":"<code>real(kind=dp) :: dist_cutoff</code>","text":"<p>The largest distance between two WFs for which the Hamiltonian matrix element is retained and used in the band interpolation (when \\(\\verb#bands_plot_mode#=\\verb#cut#\\)) or in the transport calculation. Units are \u00c5.</p> <p>The default value is 1000.0.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-dist_cutoff_mode","title":"<code>character(len=20) :: dist_cutoff_mode</code>","text":"<p>Dimension in which the distance between two WFs is calculated. The vector connecting two WFs may be projected to a line (<code>one_dim</code>) or a plane (<code>two_dim</code>). The size of the projected vector is calculated, and <code>dist_cutoff</code> is applied. When <code>one_dim</code> or <code>two_dim</code> is used, <code>one_dim_axis</code> must be given to specify extended or confined direction.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>three_dim</code> (default)</p> </li> <li> <p><code>two_dim</code></p> </li> <li> <p><code>one_dim</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen20-one_dim_axis","title":"<code>character(len=20) :: one_dim_axis</code>","text":"<p>Extended direction for a one-dimensional system or confined direction for a two-dimensional system. This direction must be parallel to one of the Cartesian axes.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>x</code></p> </li> <li> <p><code>y</code></p> </li> <li> <p><code>z</code></p> </li> </ul> <p>No default.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>F. Gygi, J. L. Fattebert, and E. Schwegler. Computation of maximally localized wannier functions using a simultaneous diagonalization algorithm. Comput. Phys. Commun., 155:1\u20136, 2003.\u00a0\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9</p> </li> <li> <p>R. Sakuma. Symmetry-adapted wannier functions in the maximal localization procedure. Phys. Rev. B, 87:235109, 2013.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Runzhi Wang, Emanuel A. Lazar, Hyowon Park, Andrew J. Millis, and Chris A. Marianetti. Selectively localized wannier functions. Physical Review B, 10 2014. doi:10.1103/PhysRevB.90.165125.\u00a0\u21a9\u21a9</p> </li> <li> <p>Marco Buongiorno Nardelli. Electronic transport in extended systems: application to carbon nanotubes. Phys. Rev. B, 60:7828, 1999.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/postproc/","title":"<code>wannier90</code>\u00a0as a post-processing tool","text":"<p>This is a description of how to use <code>wannier90</code>\u00a0as a post-processing tool.</p> <p>The code must be run twice. On the first pass either the logical keyword <code>postproc_setup</code> must be set to <code>.true.</code> in the input file <code>seedname.win</code> or the code must be run with the command line option <code>-pp</code>. Running the code then generates the file <code>seedname.nnkp</code> which provides the information required to construct the \\(M_{mn}^{(\\mathbf{k,b})}\\) overlaps (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)) and \\(A_{mn}^{(\\mathbf{k})}\\) (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)).</p> <p>Once the overlaps and projection have been computed and written to files <code>seedname.mmn</code> and <code>seedname.amn</code>, respectively, set <code>postproc_setup</code> to <code>.false.</code> and run the code. Output is written to the file <code>seedname.wout</code>.</p>"},{"location":"user_guide/wannier90/postproc/#seednamennkp-file","title":"<code>seedname.nnkp</code> file","text":"<p>OUTPUT, if \\(\\verb#postproc_setup#=\\verb#.true.#\\)</p> <p>The file <code>seedname.nnkp</code> provides the information needed to determine the required overlap elements \\(M_{mn}^{(\\mathbf{k,b})}\\) and projections \\(A_{mn}^{(\\mathbf{k})}\\). It is written automatically when the code is invoked with the <code>-pp</code> command-line option (or when <code>postproc_setup=.true.</code> in <code>seedname.win</code>. There should be no need for the user to edit this file.</p> <p>Much of the information in <code>seedname.nnkp</code> is arranged in blocks delimited by the strings <code>begin block_name</code> ... <code>end block_name</code>, as described below.</p>"},{"location":"user_guide/wannier90/postproc/#keywords","title":"Keywords","text":"<p>The first line of the file is a user comment, e.g., the date and time:</p> <p><code>File written on 12Feb2006 at 15:13:12</code></p> <p>The only logical keyword is <code>calc_only_A</code>, eg,</p> <p><code>calc_only_A  :  F</code></p>"},{"location":"user_guide/wannier90/postproc/#real_lattice-block","title":"<code>Real_lattice</code> block","text":"<pre><code>begin real_lattice\n 2.250000   0.000000   0.000000\n 0.000000   2.250000   0.000000\n 0.000000   0.000000   2.250000\nend real_lattice\n</code></pre> <p>The real lattice vectors in units of Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#recip_lattice-block","title":"<code>Recip_lattice</code> block","text":"<pre><code>begin recip_lattice\n 2.792527   0.000000   0.000000\n 0.000000   2.792527   0.000000\n 0.000000   0.000000   2.792527\nend recip_lattice\n</code></pre> <p>The reciprocal lattice vectors in units of inverse Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#kpoints-block","title":"<code>Kpoints</code> block","text":"<pre><code>begin kpoints\n  8\n  0.00000   0.00000   0.00000\n  0.00000   0.50000   0.00000\n  .\n  .\n  .\n  0.50000   0.50000   0.50000\nend kpoints\n</code></pre> <p>The first line in the block is the total number of k-points <code>num_kpts</code>. The subsequent <code>num_kpts</code> lines specify the k-points in crystallographic co-ordinates relative to the reciprocal lattice vectors.</p>"},{"location":"user_guide/wannier90/postproc/#projections-block","title":"<code>Projections</code> block","text":"<pre><code>begin projections\n   n_proj\n   centre   l  mr  r   \n     z-axis   x-axis   zona\n   centre   l  mr  r   \n     z-axis   x-axis   zona\n   .\n   .\nend projections\n</code></pre> <p>Notes:</p> <p><code>n_proj</code>: integer; the number of projection centres, equal to the number of MLWF <code>num_wann</code>.</p> <p><code>centre</code>: three real numbers; projection function centre in crystallographic co-ordinates relative to the direct lattice vectors.</p> <p><code>l  mr  r</code>: three integers; \\(l\\) and \\(m_\\mathrm{r}\\) specify the angular part \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\), and \\(\\mathrm{r}\\) specifies the radial part \\(R_{\\mathrm{r}}(r)\\) of the projection function (see Tables\u00a03.1{reference-type=\"ref\" reference=\"tab:angular\"}, 3.2{reference-type=\"ref\" reference=\"tab:hybrids\"} and 3.3{reference-type=\"ref\" reference=\"tab:radial\"}).</p> <p><code>z-axis</code>: three real numbers; default is <code>0.0 0.0 1.0</code>; defines the axis from which the polar angle \\(\\theta\\) in spherical polar coordinates is measured.</p> <p><code>x-axis</code>: three real numbers; must be orthogonal to <code>z-axis</code>; default is <code>1.0 0.0 0.0</code> or a vector perpendicular to <code>z-axis</code> if <code>z-axis</code> is given; defines the axis from with the azimuthal angle \\(\\varphi\\) in spherical polar coordinates is measured.</p> <p><code>zona</code>: real number; the value of \\(\\frac{Z}{a}\\) associated with the radial part of the atomic orbital. Units are in reciprocal Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#spinor_projections-block","title":"<code>spinor_projections</code> block","text":"<pre><code>begin spinor_projections\n   n_proj\n   centre   l  mr  r   \n    z-axis   x-axis   zona\n     spin spn_quant\n   centre   l  mr  r   \n    z-axis   x-axis   zona\n     spin spn_quant\n   .\n   .\nend spinor_projections\n</code></pre> <p>Notes: Only one of projections and spinor_projections should be defined. Variables are the same as the projections block with the addition of <code>spin</code> and <code>spn_quant</code>.</p> <p><code>spin</code>: integer. '1' or '-1' to denote projection onto up or down states.</p> <p><code>spn_quant</code>: three real numbers. Defines the spin quantisation axis in Cartesian coordinates.</p>"},{"location":"user_guide/wannier90/postproc/#nnkpts-block","title":"<code>nnkpts</code> block","text":"<pre><code>begin nnkpts\n  10\n  1   2   0  0  0\n  .\n  .\nend nnkpts\n</code></pre> <p>First line: <code>nntot</code>, the number of nearest neighbours belonging to each k-point of the Monkhorst-Pack mesh</p> <p>Subsequent lines: <code>nntot</code>\\(\\times\\)<code>num_kpts</code> lines, ie, <code>nntot</code> lines of data for each k-point of the mesh.</p> <p>Each line of consists of 5 integers. The first is the k-point number <code>nkp</code>. The second to the fifth specify it's nearest neighbours \\(\\mathbf{k+b}\\): the second integer points to the k-point that is the periodic image of the \\(\\mathbf{k+b}\\) that we want; the last three integers give the G-vector, in reciprocal lattice units, that brings the k-point specified by the second integer (which is in the first BZ) to the actual \\(\\mathbf{k+b}\\) that we need.</p>"},{"location":"user_guide/wannier90/postproc/#exclude_bands-block","title":"<code>exclude_bands</code> block","text":"<pre><code>begin exclude_bands \n  8 \n  1 \n  2 \n  .\n  .\nend exclude_bands\n</code></pre> <p>To exclude bands (independent of k-point) from the calculation of the overlap and projection matrices, for example to ignore shallow-core states. The first line is the number of states to exclude, the following lines give the states for be excluded.</p>"},{"location":"user_guide/wannier90/postproc/#secauto-projections-block-labelsecauto-projections-blockauto_projections-block","title":"[]{#sec:auto-projections-block label=\"sec:auto-projections-block\"}<code>auto_projections</code> block","text":"<pre><code>begin auto_projections\n   8\n   0\nend auto_projections\n</code></pre> <p>This block is only printed if <code>auto_projections=true</code> in the input. The choice of an additional block has been made in order to maintain back-compatibility with codes that interface with <code>wannier90</code>, e.g. <code>pw2wannier90</code>. The first entry in the block (in the example above, <code>8</code>) is the total number of target projections and it is equal to the number of sought Wannier functions.</p> <p>The second entry is a reserved flag with the value of zero. The implementations of the interface codes MUST check for this value to be zero and stop otherwise. In the future, one possible extension that we plan is to combine the automatic generation of initial projections with the selection of projections via a projections block. This will allow the user to specify only a subset of initial projections in the projections block and leave the interface code to automatically generate the remaining ones. In that case the constraint on the second entry will be lifted, so that it can take on the meaning of the number of projections that need to be generated automatically.</p> <p>The selected columns of the density matrix (SCDM) method\u00a0<sup>3</sup> is one way of generating the initial \\(A_{mn}^{(\\mathbf{k})}\\) in an automatic way. This has been implemented in the <code>pw2wannier90</code> interface code (you need v6.3 with the files provided in the <code>pwscf</code> folder of Wannier90, or v6.4), see for instance Example 27 in the <code>wannier90</code>\u00a0tutorial that shows how to use it.</p> <p>Moreover, also the automatic generation of initial projections with spinor WFs is implemented in the <code>pw2wannier90</code> interface. See Example 31 in the <code>wannier90</code>\u00a0tutorial that shows how to use it.</p> <p>Another automatic projection method is projectability-disentangled Wannier function (PDWF) <sup>4</sup>, which uses pseudo-atomic orbitals inside pseudopotentials as initial guesses. See Example 34 and 35.</p>"},{"location":"user_guide/wannier90/postproc/#sec:proj_example","title":"An example of projections","text":"<p>As a concrete example: one wishes to have a set of four sp\\(^3\\) projection orbitals on, say, a carbon atom at (0.5,0.5,0.5) in fractional co-ordinates relative to the direct lattice vectors. In this case <code>seedname.win</code> will contain the following lines:</p> <pre><code>begin projections\n C:l=-1\nend projections\n</code></pre> <p>and <code>seedname.nnkp</code>, generated on the first pass of <code>wannier90</code>\u00a0(with <code>postproc_setup=T</code>), will contain:</p> <pre><code>begin projections\n   4\n   0.50000    0.50000    0.50000    -1  1  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.50000    0.50000    0.50000    -1  2  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.50000    0.50000    0.50000    -1  3  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.50000    0.50000    0.50000    -1  4  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \nend projections\n</code></pre> <p>where the first line tells us that in total four projections are specified, and the subsquent lines provide the projection centre, the angular and radial parts of the orbital (see Section\u00a03.4{reference-type=\"ref\" reference=\"sec:orbital-defs\"} for definitions), the \\(z\\) and \\(x\\) axes, and the diffusivity and cut-off radius for the projection orbital.</p> <p>[pwscf]{.smallcaps}, or any other ab initio electronic structure code, then reads <code>seedname.nnkp</code> file, calculates the projections and writes them to <code>seedname.amn</code>.</p>"},{"location":"user_guide/wannier90/postproc/#seednamemmn-file","title":"<code>seedname.mmn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.mmn</code> contains the overlaps \\(M_{mn}^{(\\mathbf{k,b})}\\).</p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 3 integers: <code>num_bands</code>, <code>num_kpts</code>, <code>nntot</code></p> <p>Then: \\(\\verb#num_kpts#\\times\\verb#nntot#\\) blocks of data:</p> <p>First line of each block: 5 integers. The first specifies the \\(\\mathbf{k}\\) (i.e., gives the ordinal corresponding to its position in the list of k-points in <code>seedname.win</code>). The 2<sup>nd</sup> to 5<sup>th</sup> integers specify \\(\\mathbf{k+b}\\). The 2<sup>nd</sup> integer, in particular, points to the k-point on the list that is a periodic image of \\(\\mathbf{k+b}\\), and in particular is the image that is actually mentioned in the list. The last three integers specify the \\(\\mathbf{G}\\) vector, in reciprocal lattice units, that brings the k-point specified by the second integer, and that thus lives inside the first BZ zone, to the actual \\(\\mathbf{k+b}\\) that we need.</p> <p>Subsequent \\(\\verb#num_bands#\\times\\verb#num_bands#\\) lines of each block: two real numbers per line. These are the real and imaginary parts, respectively, of the actual scalar product \\(M_{mn}^{(\\mathbf{k,b})}\\) for \\(m,n \\in [1,\\verb#num_bands#]\\). The order of these elements is such that the first index \\(m\\) is fastest.</p>"},{"location":"user_guide/wannier90/postproc/#seednameamn-file","title":"<code>seedname.amn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.amn</code> contains the projection \\(A_{mn}^{(\\mathbf{k})}\\).</p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 3 integers: <code>num_bands</code>, <code>num_kpts</code>, <code>num_wann</code></p> <p>Subsequently \\(\\verb#num_bands#\\times\\verb#num_wann#\\times\\verb#num_kpts#\\) lines: 3 integers and 2 real numbers on each line. The first two integers are the band index \\(m\\) and the projection index \\(n\\), respectively. The third integer specifies the \\(\\mathbf{k}\\) by giving the ordinal corresponding to its position in the list of \\(k\\)-points in <code>seedname.win</code>. The real numbers are the real and imaginary parts, respectively, of the actual \\(A_{mn}^{(\\mathbf{k})}\\).</p>"},{"location":"user_guide/wannier90/postproc/#seednamedmn-file","title":"<code>seedname.dmn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.dmn</code> contains the data needed to construct symmetry-adapted Wannier functions\u00a0<sup>5</sup>. Required if <code>site_symmetry = .true.</code></p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 4 integers: <code>num_bands</code>, <code>nsymmetry</code>, <code>nkptirr</code>, <code>num_kpts</code>.\\ <code>nsymmetry</code>: the number of symmetry operations\\ <code>nkptirr</code>: the number of irreducible k-points</p> <p>Blank line</p> <p><code>num_kpts</code> integers: Mapping between full k- and irreducible k-points. Each k-point is related to some k-point in the irreducible BZ. The information of this mapping is written. Each entry corresponds to a k-point in the full BZ, in the order in which they appear in the k-point list in <code>seedname.win</code> file. The (integer) value of each entry is the k-point index in the IBZ to which the k-point maps. The number of unique values is equal to the number of k-points in the IBZ. The data is written 10 values per line.</p> <p>Blank line</p> <p><code>nkptirr</code> integers: List of irreducible k-points. Each entry corresponds to a k-point of the IBZ. The (integer) value of each entry is the k-point index corresponding to the k-point list in <code>seedname.win</code> file. The values should be between 1 and <code>num_kpts</code>. The data is written 10 values per line.</p> <p>Blank line</p> <p><code>nkptirr</code> blocks of <code>nsymmetry</code> integer data (each block separated by a blank line): List of k-points obtained by acting the symmetry operations on the irreducible k-points. The data is written 10 values per line.</p> <p>Blank line</p> <p>\\(\\verb#nsymmetry# \\times \\verb#nkptirr#\\) blocks of data:\\ The information of \\(D\\) matrix in Eq. (15) of Ref.\u00a0<sup>5</sup>. Each block contains \\(\\verb#num_wann# \\times \\verb#num_wann#\\) lines and is separated by a blank line. The data are stored in <code>d_matrix_wann(m,n,isym,ikirr)</code> with \\(\\verb#m#, \\verb#n# \\in [1,\\verb#num_wann#]\\), \\(\\verb#isym# \\in [1,\\verb#nsymmetry#]\\), and \\(\\verb#ikirr# \\in [1,\\verb#nkptirr#]\\). The order of the elements is such that left indices run faster than right indices (<code>m</code>: fastest, <code>ikirr</code>: slowest).</p> <p>Blank line</p> <p>\\(\\verb#nsymmetry# \\times \\verb#nkptirr#\\) blocks of data:\\ The information of \\(\\tilde d\\) matrix in Eq. (17) of Ref.\u00a0<sup>5</sup>. Each block contains \\(\\verb#num_bands# \\times \\verb#num_bands#\\) lines and is separated by a blank line. The data are stored in <code>d_matrix_band(m,n,isym,ikirr)</code> with \\(\\verb#m#, \\verb#n# \\in [1,\\verb#num_bands#]\\), \\(\\verb#isym# \\in [1,\\verb#nsymmetry#]\\), and \\(\\verb#ikirr# \\in [1,\\verb#nkptirr#]\\). The order of the elements is such that left indices run faster than right indices (<code>m</code>: fastest, <code>ikirr</code>: slowest).</p>"},{"location":"user_guide/wannier90/postproc/#seednameeig-file","title":"<code>seedname.eig</code> file","text":"<p>INPUT.</p> <p>Required if any of <code>disentanglement</code>, <code>plot_bands</code>, <code>plot_fermi_surface</code> or <code>write_hr</code> are <code>.true.</code></p> <p>The file <code>seedname.eig</code> contains the Kohn-Sham eigenvalues \\(\\varepsilon_{n\\mathbf{k}}\\) (in eV) at each point in the Monkhorst-Pack mesh.</p> <p>Each line consist of two integers and a real number. The first integer is the band index, the second integer gives the ordinal corresponding to the \\(k\\)-point in the list of \\(k\\)-points in <code>seedname.win</code>, and the real number is the eigenvalue.</p> <p>E.g.,</p> <pre><code>           1           1  -6.43858831271328\n           2           1   19.3977795287297\n           3           1   19.3977795287297\n           4           1   19.3977795287298\n</code></pre>"},{"location":"user_guide/wannier90/postproc/#interface-with-pwscf","title":"Interface with pwscf","text":"<p>Interfaces between <code>wannier90</code>\u00a0and many ab-initio codes such as [pwscf]{.smallcaps}, abinit (http://www.abinit.org), siesta (http://www.icmab.es/siesta/), fleur, VASP and Wien2k (http://www.wien2k.at) are available. Here we describe the seamless interface between <code>wannier90</code>\u00a0and [pwscf]{.smallcaps}, a plane-wave DFT code that comes as part of the Quantum ESPRESSO package (see http://www.quantum-espresso.org). You will need to download and compile [pwscf]{.smallcaps}\u00a0(i.e., the <code>pw.x</code> code) and the post-processing interface <code>pw2wannier90.x</code>. Please refer to the documentation that comes with the Quantum ESPRESSO distribution for instructions.</p> <ol> <li> <p>Run 'scf'/'nscf' calculation(s) with <code>pw</code></p> </li> <li> <p>Run <code>wannier90</code>\u00a0with <code>postproc_setup</code>\u00a0=\u00a0<code>.true.</code> to generate     <code>seedname.nnkp</code></p> </li> <li> <p>Run <code>pw2wannier90</code>. First it reads an input file, e.g.,     <code>seedname.pw2wan</code>, which defines <code>prefix</code> and <code>outdir</code> for the     underlying 'scf' calculation, as well as the name of the file     <code>seedname.nnkp</code>, and does a consistency check between the direct and     reciprocal lattice vectors read from <code>seedname.nnkp</code> and those     defined in the files specified by <code>prefix</code>. <code>pw2wannier90</code> generates     <code>seedname.mmn</code>, <code>seedname.amn</code> and <code>seedname.eig</code>. <code>seedname.dmn</code>     and <code>seedname.sym</code> files are additionally created when     <code>write_dmn = .true.</code> (see below).</p> </li> <li> <p>Run <code>wannier90</code> with <code>postproc_setup</code>\u00a0=\u00a0<code>.false.</code> to disentangle     bands (if required), localise MLWF, and use MLWF for plotting,     bandstructures, Fermi surfaces etc.</p> </li> </ol> <p>Examples of how the interface with [pwscf]{.smallcaps}\u00a0works are given in the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/postproc/#seednamepw2wan","title":"<code>seedname.pw2wan</code>","text":"<p>A number of keywords may be specified in the <code>pw2wannier90</code> input file:</p> <ul> <li> <p><code>outdir</code> -- Location to write output files. Default is <code>`./'</code></p> </li> <li> <p><code>prefix</code> -- Prefix for the [pwscf]{.smallcaps}\u00a0calculation. Default     is <code>` '</code></p> </li> <li> <p><code>seedname</code> -- Seedname for the <code>wannier90</code>\u00a0calculation. Default is     <code>`wannier'</code></p> </li> <li> <p><code>spin_component</code> -- Spin component. Takes values <code>`up'</code>,     <code>`down'</code> or <code>`none'</code> (default).</p> </li> <li> <p><code>wan_mode</code> -- Either <code>`standalone'</code> (default) or <code>`library'</code></p> </li> <li> <p><code>write_unk</code> -- Set to <code>.true.</code> to write the periodic part of the     Bloch functions for plotting in <code>wannier90</code>. Default is <code>.false.</code></p> </li> <li> <p><code>reduce_unk</code> -- Set to <code>.true.</code> to reduce file-size (and resolution)     of Bloch functions by a factor of 8. Default is <code>.false.</code> (only     relevant if <code>write_unk=.true.</code>)</p> <p>Note</p> <p>Note that there is a small bug with this feature in v3.2 (and subsequent patches) of <code>quantum-espresso</code>. Please use a later version (if available) or the CVS version of <code>pw2wannier90.f90</code>, which has been fixed.</p> </li> <li> <p><code>wvfn_formatted</code> -- Set to <code>.true.</code> to write formatted     wavefunctions. Default is <code>.false.</code> (only relevant if     <code>write_unk=.true.</code>)</p> </li> <li> <p><code>write_amn</code> -- Set to <code>.false.</code> if \\(A_{mn}^{(\\mathbf{k})}\\) not     required. Default is <code>.true.</code></p> </li> <li> <p><code>write_mmn</code> -- Set to <code>.false.</code> if \\(M_{mn}^{(\\mathbf{k,b})}\\) not     required. Default is <code>.true.</code></p> </li> <li> <p><code>write_spn</code> -- Set to <code>.true.</code> to write out the matrix elements of     \\(S\\) between Bloch states (non-collinear spin calculation only).     Default is <code>.false.</code></p> </li> <li> <p><code>spn_formatted</code> -- Set to <code>.true.</code> to write spn data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_spn=.true.</code>)</p> </li> <li> <p><code>write_uHu</code> -- Set to <code>.true.</code> to write out the matrix elements     \\(\\(\\langle u_{n{\\bf k}+{\\bf b}_1}\\vert     H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle.\\)\\) Default is <code>.false.</code></p> </li> <li> <p><code>uHu_formatted</code> -- Set to <code>.true.</code> to write uHu data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_uHu=.true.</code>)</p> </li> <li> <p><code>write_uIu</code> -- Set to <code>.true.</code> to write out the matrix elements of     \\(\\(\\langle  u_{n{\\bf k}+{\\bf b}_1}\\vert     u_{m{\\bf k}+{\\bf b}_2}\\rangle.\\)\\) Default is <code>.false.</code></p> </li> <li> <p><code>uIu_formatted</code> -- Set to <code>.true.</code> to write uIu data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_uIu=.true.</code>)</p> </li> <li> <p><code>write_unkg</code> -- Set to <code>.true.</code> to write the first few Fourier     components of the periodic parts of the Bloch functions.</p> </li> <li> <p><code>write_dmn</code> -- Set to <code>.true.</code> to construct symmetry-adapted Wannier     functions. Default is <code>.false.</code></p> </li> <li> <p><code>read_sym</code> -- Set to <code>.true.</code> to customize symmetry operations to be     used in symmetry-adapted mode. When <code>read_sym = .true.</code>, an     additional input <code>seedname.sym</code> is required. Default is <code>.false.</code>     (only relevant if <code>write_dmn=.true.</code>).</p> </li> <li> <p><code>atom_proj</code> -- Set to <code>.true.</code> to use pseudo-atomic orbitals for     computing <code>amn</code>. Default is <code>.false.</code>.</p> </li> <li> <p><code>atom_proj_exclude</code> -- A list of integers specifying the indices of     pseudo-atomic projectors to be excluded from computing <code>amn</code>. Used     only when <code>atom_proj = .true.</code>. No default.</p> </li> <li> <p><code>atom_proj_ext</code> -- Set to <code>.true.</code> to use external pseudo-atomic     orbitals for computing <code>amn</code>, will read data files from directory     <code>atom_proj_dir</code>. Used only when <code>atom_proj = .true.</code>. Default is     <code>.false.</code>.</p> </li> <li> <p><code>atom_proj_dir</code> -- A string specifying the directory for external     pseudo-atomic projectors. Used only when <code>atom_proj = .true.</code> and     <code>atom_proj_ext = .true.</code>. No default.</p> </li> </ul> <p>For examples of use, refer to the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/postproc/#seednamesym","title":"<code>seedname.sym</code>","text":"<p>If <code>read_sym = .true.</code>, then this additional input file is required for <code>pw2wannier90.x</code>\\ if <code>read_sym = .false.</code>, then this file is written by <code>pw2wannier90.x</code> (only for reference -- it is not used in subsequent calculations)</p> <p>The file <code>seedname.sym</code> contains the information of symmetry operations used to create symmetry-adapted Wannier functions. If <code>read_sym = .false.</code> (default), <code>pw2wannier90.x</code> uses the full symmetry recognized by <code>pw.x</code>. If <code>read_sym = .true.</code>, you can specify symmetry operations to be used in symmetry-adapted mode.</p> <p>First line: an integer: <code>nsymmetry</code> (number of symmetry operations)</p> <p>Second line: blank</p> <p>Then: <code>nsymmetry</code> blocks of data. Each block (separated by a blank line) consists of four lines. The order of the data in each block is as follows:</p> <pre><code>  R(1,1)   R(2,1)   R(3,1)\n  R(1,2)   R(2,2)   R(3,2)\n  R(1,3)   R(2,3)   R(3,3)\n   t(1)     t(2)     t(3)\n</code></pre> <p>Here, \\(R\\) is the rotational part of symmetry operations (\\(3\\times3\\) matrix), and \\(\\bf t\\) is the fractional translation in the unit of \"<code>alat</code>\" (refer the definition of \"<code>alat</code>\" to the manual of [pwscf]{.smallcaps}). Both data are given in Cartesian coordinates. The symmetry operations act on a point \\(\\bf r\\) as \\({\\bf r} R - {\\bf t}\\).</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9</p> </li> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9</p> </li> <li> <p>Junfeng Qiao, Giovanni Pizzi, and Nicola Marzari. Projectability disentanglement for accurate and automated electronic-structure Hamiltonians. npj Comput. Mater., 9(1):208, Nov 2023. doi:10.1038/s41524-023-01146-w.\u00a0\u21a9</p> </li> <li> <p>R. Sakuma. Symmetry-adapted wannier functions in the maximal localization procedure. Phys. Rev. B, 87:235109, 2013.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/projections/","title":"Projections","text":""},{"location":"user_guide/wannier90/projections/#sec:proj","title":"Specification of projections in <code>seedname.win</code>","text":"<p>Here we describe the projection functions used to construct the initial guess \\(A_{mn}^{(\\mathbf{k})}\\) for the unitary transformations.</p> <p>Each projection is associated with a site and an angular momentum state defining the projection function. Optionally, one may define, for each projection, the spatial orientation, the radial part, the diffusivity, and the volume over which real-space overlaps \\(A_{mn}\\) are calculated.</p> <p>The code is able to</p> <ol> <li> <p>project onto s,p,d and f angular momentum states, plus the hybrids     sp, sp\\(^2\\), sp\\(^3\\), sp\\(^3\\)d, sp\\(^3\\)d\\(^2\\).</p> </li> <li> <p>control the radial part of the projection functions to allow higher     angular momentum states, e.g., both 3s and 4s in silicon.</p> </li> </ol> <p>The atomic orbitals of the hydrogen atom provide a good basis to use for constructing the projection functions: analytical mathematical forms exist in terms of the good quantum numbers \\(n\\), \\(l\\) and \\(m\\); hybrid orbitals (sp, sp\\(^{2}\\), sp\\(^{3}\\), sp\\(^{3}\\)d etc.) can be constructed by simple linear combination \\(|\\phi\\rangle = \\sum_{nlm} C_{nlm}|nlm\\rangle\\) for some coefficients \\(C_{nlm}\\).</p> <p>The angular functions that use as a basis for the projections are not the canonical spherical harmonics \\(Y_{lm}\\) of the hydrogenic Schr\u00f6dinger equation but rather the real (in the sense of non-imaginary) states \\(\\Theta_{lm_{\\mathrm{r}}}\\), obtained by a unitary transformation. For example, the canonical eigenstates associated with \\(l=1\\), \\(m=\\{-1,0,1\\}\\) are not the real p\\(_{x}\\), p\\(_{y}\\) and p\\(_{z}\\) that we want. See Section\u00a03.4{reference-type=\"ref\" reference=\"sec:orbital-defs\"} for our mathematical conventions regarding projection orbitals for different \\(n\\), \\(l\\) and \\(m_{\\mathrm{r}}\\).</p> <p>We use the following format to specify projections in <code>&lt;seedname&gt;.win</code>:</p> <p><code>Begin Projections</code>\\ <code>[units]</code>\\ <code>site:ang_mtm:zaxis:xaxis:radial:zona</code>\\ <code></code>\u22ee\\ <code>End Projections</code></p> <p>Notes:</p> <p><code>units</code>:\\ Optional. Either <code>Ang</code> or <code>Bohr</code> to specify whether the projection centres specified in this block (if given in Cartesian co-ordinates) are in units of Angstrom or Bohr, respectively. The default value is <code>Ang</code>.</p> <p><code>site</code>:\\ <code>C</code>, <code>Al</code>, etc. applies to all atoms of that type\\ <code>f=0,0.50,0</code> -- centre on (0.0,0.5,0.0) in **f**ractional coordinates (crystallographic units) relative to the direct lattice vectors\\ <code>c=0.0,0.805,0.0</code> -- centre on (0.0,0.805,0.0) in **C**artesian coordinates in units specified by the optional string <code>units</code> in the first line of the projections block (see above).</p> <p><code>ang_mtm</code>:\\ Angular momentum states may be specified by <code>l</code> and <code>mr</code>, or by the appropriate character string. See Tables\u00a03.1 and 3.2. Examples:\\ <code>l=2,mr=1</code> or <code>dz2</code> -- a single projection with \\(l=2\\), \\(m_{\\textrm{r}}=1\\) (i.e., d\\(_{z^{2}}\\))\\ <code>l=2,mr=1,4</code> or <code>dz2,dx2-y2</code> -- two functions: d\\(_{z^{2}}\\) and d\\(_{xz}\\)\\ <code>l=-3</code> or <code>sp3</code> -- four sp\\(^{3}\\) hybrids\\ Specific hybrid orbitals may be specified as follows:\\ <code>l=-3,mr=1,3</code> or <code>sp3-1,sp3-3</code> -- two specific sp\\(^{3}\\) hybrids\\ Multiple states may be specified by separating with '<code>;</code>', e.g.,\\ <code>sp3;l=0</code> or <code>l=-3;l=0</code> -- four sp\\(^{3}\\) hybrids and one s orbital</p> <p><code>zaxis</code> (optional):\\ <code>z=1,1,1</code> -- set the \\(z\\)-axis to be in the (1,1,1) direction. Default is <code>z=0,0,1</code></p> <p><code>xaxis</code> (optional):\\ <code>x=1,1,1</code> -- set the \\(x\\)-axis to be in the (1,1,1) direction. Default is <code>x=1,0,0</code></p> <p><code>radial</code> (optional):\\ <code>r=2</code> -- use a radial function with one node (ie second highest pseudostate with that angular momentum). Default is <code>r=1</code>. Radial functions associated with different values of <code>r</code> should be orthogonal to each other.</p> <p><code>zona</code> (optional):\\ <code>zona=2.0</code> -- the value of \\(\\frac{Z}{a}\\) for the radial part of the atomic orbital (controls the diffusivity of the radial function). Units always in reciprocal Angstrom. Default is <code>zona=1.0</code>.</p> <p>Examples</p> <p>1. CuO, s,p and d on all Cu; sp\\(^3\\) hybrids on O:</p> <p><code>Cu:l=0;l=1;l=2</code></p> <p><code>O:l=-3</code> or <code>O:sp3</code></p> <p>2. A single projection onto a p\\(_z\\) orbital orientated in the (1,1,1) direction:</p> <p><code>c=0,0,0:l=1,mr=1:z=1,1,1</code> or <code>c=0,0,0:pz:z=1,1,1</code></p> <p>3. Project onto s, p and d (with no radial nodes), and s and p (with one radial node) in silicon:</p> <p><code>Si:l=0;l=1;l=2</code></p> <p><code>Si:l=0;l=1:r=2</code></p>"},{"location":"user_guide/wannier90/projections/#spinor-projections","title":"Spinor Projections","text":"<p>When <code>spinors=.true.</code> it is possible to select a set of localised functions to project onto 'up' states and a set to project onto 'down' states where, for complete flexibility, it is also possible to set the local spin quantisation axis.</p> <p>Note, however, that this feature requires a recent version of the interface between the ab-initio code and Wannier90 (i.e., written after the release of the 2.0 version, in October 2013) supporting spinor projections.</p> <p><code>Begin Projections</code>\\ <code>[units]</code>\\ <code>site:ang_mtm:zaxis:xaxis:radial:zona(spin)[quant_dir]</code>\\ <code></code>\u22ee\\ <code>End Projections</code></p> <p><code>spin</code> (optional):\\ Choose projection onto 'up' or 'down' states\\ <code>u</code> -- project onto 'up' states.\\ <code>d</code> -- project onto 'down' states.\\ Default is <code>u,d</code></p> <p><code>quant_dir</code> (optional):\\ <code>1,0,0</code> -- set the spin quantisation axis to be in the (1,0,0) direction. Default is <code>0,0,1</code></p> <p>Examples</p> <ul> <li> <p>18 projections on an iron site</p> <p><code>Fe:sp3d2;dxy;dxx;dyz</code></p> </li> <li> <p>same as above</p> <p><code>Fe:sp3d2;dxy;dxx;dyz(u,d)</code></p> </li> <li> <p>same as above</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u,d)[0,0,1]</code></p> </li> <li> <p>same as above but quantisation axis is now x</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u,d)[1,0,0]</code></p> </li> <li> <p>now only 9 projections onto up states</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u)</code></p> </li> <li> <p>9 projections onto up-states and 3 on down</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u)</code>\\ <code>Fe:dxy;dxz;dyz(d)</code></p> </li> <li> <p>projections onto alternate spin states for two lattice sites (Cr1,     Cr2)</p> <p><code>Cr1:d(u)</code>\\ <code>Cr2:d(d)</code></p> </li> </ul>"},{"location":"user_guide/wannier90/projections/#short-cuts","title":"Short-Cuts","text":""},{"location":"user_guide/wannier90/projections/#random-projections","title":"Random projections","text":"<p>It is possible to specify the projections, for example, as follows:</p> <p><code>Begin Projections</code>\\ <code>random</code>\\ <code>C:sp3</code>\\ <code>End Projections</code></p> <p>in which case <code>wannier90</code>\u00a0uses four sp\\(^3\\) orbitals centred on each C atom and then chooses the appropriate number of randomly-centred s-type Gaussian functions for the remaining projection functions. If the block only consists of the string <code>random</code> and no specific projection centres are given, then all of the projection centres are chosen randomly.</p>"},{"location":"user_guide/wannier90/projections/#bloch-phases","title":"Bloch phases","text":"<p>Setting <code>use_bloch_phases = true</code> in the input file absolves the user of the need to specify explicit projections. In this case, the Bloch wave-functions are used as the projection orbitals, namely \\(A_{mn}^{(\\mathbf{k})} = \\langle\\psi_{m\\mathbf{k}}|\\psi_{n\\mathbf{k}}\\rangle = \\delta_{mn}\\).</p>"},{"location":"user_guide/wannier90/projections/#sec:orbital-defs","title":"Orbital Definitions","text":"<p>The angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) are given in Tables\u00a03.1{reference-type=\"ref\" reference=\"tab:angular\"} and 3.2{reference-type=\"ref\" reference=\"tab:hybrids\"}.</p> <p>The radial functions \\(R_{\\mathrm{r}}(r)\\) associated with different values of \\(r\\) should be orthogonal. One choice would be to take the set of solutions to the radial part of the hydrogenic Schr\u00f6dinger equation for \\(l=0\\), i.e., the radial parts of the 1s, 2s, 3s...\u00a0orbitals, which are given in Table\u00a03.3{reference-type=\"ref\" reference=\"tab:radial\"}.</p> <p>::: center ::: {#tab:angular}</p> <p>\\(l\\) \\(m_{\\mathrm{r}}\\)       Name                               \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\)</p> <pre><code>0           1               `s`                                          $\\frac{1}{\\sqrt{4\\pi}}$\n\n\n1           1               `pz`                                    $\\sqrt{\\frac{3}{4\\pi}}\\cos\\theta$\n\n1           2               `px`                              $\\sqrt{\\frac{3}{4\\pi}}\\sin\\theta\\cos\\varphi$\n\n1           3               `py`                              $\\sqrt{\\frac{3}{4\\pi}}\\sin\\theta\\sin\\varphi$\n\n\n2           1              `dz2`                              $\\sqrt{\\frac{5}{16\\pi}}(3\\cos^{2}\\theta -1)$\n\n2           2              `dxz`                         $\\sqrt{\\frac{15}{4\\pi}}\\sin\\theta\\cos\\theta\\cos\\varphi$\n\n2           3              `dyz`                         $\\sqrt{\\frac{15}{4\\pi}}\\sin\\theta\\cos\\theta\\sin\\varphi$\n\n2           4             `dx2-y2`                         $\\sqrt{\\frac{15}{16\\pi}}\\sin^{2}\\theta\\cos2\\varphi$\n\n2           5              `dxy`                           $\\sqrt{\\frac{15}{16\\pi}}\\sin^{2}\\theta\\sin2\\varphi$\n\n\n3           1              `fz3`                       $\\frac{\\sqrt{7}}{4\\sqrt{\\pi}}(5\\cos^{3}\\theta-3\\cos\\theta)$\n\n3           2              `fxz2`               $\\frac{\\sqrt{21}}{4\\sqrt{2\\pi}}(5\\cos^{2}\\theta-1)\\sin\\theta\\cos\\varphi$\n\n3           3              `fyz2`               $\\frac{\\sqrt{21}}{4\\sqrt{2\\pi}}(5\\cos^{2}\\theta-1)\\sin\\theta\\sin\\varphi$\n\n3           4           `fz(x2-y2)`               $\\frac{\\sqrt{105}}{4\\sqrt{\\pi}}\\sin^{2}\\theta\\cos\\theta\\cos2\\varphi$\n\n3           5              `fxyz`                 $\\frac{\\sqrt{105}}{4\\sqrt{\\pi}}\\sin^{2}\\theta\\cos\\theta\\sin2\\varphi$\n\n3           6           `fx(x2-3y2)`   $\\frac{\\sqrt{35}}{4\\sqrt{2\\pi}}\\sin^{3}\\theta(\\cos^{2}\\varphi-3\\sin^{2}\\varphi)\\cos\\varphi$\n\n3           7           `fy(3x2-y2)`   $\\frac{\\sqrt{35}}{4\\sqrt{2\\pi}}\\sin^{3}\\theta(3\\cos^{2}\\varphi-\\sin^{2}\\varphi)\\sin\\varphi$\n</code></pre> Angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\)   associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) for   \\(l\\ge0\\). ::: ::: <p>::: center ::: {#tab:hybrids}</p> <pre><code>        $l$            $m_{\\mathrm{r}}$     Name                      $\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)$\n</code></pre> <p>\\(-\\)<code>&lt;!-- --&gt;</code>1          1            <code>sp-1</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>s</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>px</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>1          2            <code>sp-2</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>px</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>2          1            <code>sp2-1</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>py</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>2          2            <code>sp2-2</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>py</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>2          3            <code>sp2-3</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(+\\frac{2}{\\sqrt{6}}\\)<code>px</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>3          1            <code>sp3-1</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(+\\) <code>px</code> \\(+\\) <code>py</code> \\(+\\) <code>pz</code>)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>3          2            <code>sp3-2</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(+\\) <code>px</code> \\(-\\) <code>py</code> \\(-\\) <code>pz</code>)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>3          3            <code>sp3-3</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(-\\) <code>px</code> \\(+\\) <code>py</code> \\(-\\) <code>pz</code>)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>3          4            <code>sp3-4</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(-\\) <code>px</code> \\(-\\) <code>py</code> \\(+\\) <code>pz</code>)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>4          1           <code>sp3d-1</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>py</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>4          2           <code>sp3d-2</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>py</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>4          3           <code>sp3d-3</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(+\\frac{2}{\\sqrt{6}}\\)<code>px</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>4          4           <code>sp3d-4</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>pz</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>dz2</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>4          5           <code>sp3d-5</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>pz</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>dz2</code></p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          1           <code>sp3d2-1</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#-\\frac{1}{\\sqrt{2}}\\verb#px#                                                                    -\\frac{1}{\\sqrt{12}}\\verb#dz2#+\\frac{1}{2}\\verb#dx2-y2#\\)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          2           <code>sp3d2-2</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#+\\frac{1}{\\sqrt{2}}\\verb#px#                                                                    -\\frac{1}{\\sqrt{12}}\\verb#dz2#+\\frac{1}{2}\\verb#dx2-y2#\\)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          3           <code>sp3d2-3</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#-\\frac{1}{\\sqrt{2}}\\verb#py#                                                                    -\\frac{1}{\\sqrt{12}}\\verb#dz2#-\\frac{1}{2}\\verb#dx2-y2#\\)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          4           <code>sp3d2-4</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#+\\frac{1}{\\sqrt{2}}\\verb#py#                                                                    -\\frac{1}{\\sqrt{12}}\\verb#dz2#-\\frac{1}{2}\\verb#dx2-y2#\\)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          5           <code>sp3d2-5</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#-\\frac{1}{\\sqrt{2}}\\verb#pz#                                                                                 +\\frac{1}{\\sqrt{3}}\\verb#dz2#\\)</p> <p>\\(-\\)<code>&lt;!-- --&gt;</code>5          6           <code>sp3d2-6</code> \\(\\frac{1}{\\sqrt{6}}\\verb#s#+\\frac{1}{\\sqrt{2}}\\verb#pz#                                                                                 +\\frac{1}{\\sqrt{3}}\\verb#dz2#\\)</p> Angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\)   associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) for   \\(l&lt;0\\), in terms of the orbitals defined in   Table\u00a03.1{reference-type=\"ref\"   reference=\"tab:angular\"}. ::: ::: <p>::: center ::: {#tab:radial}</p> <p>\\(r\\) \\(R_{\\mathrm{r}}(r)\\)</p> <pre><code>  1            $2 \\alpha^{3/2}\\exp(-\\alpha r)$\n\n\n  2       $\\frac{1}{2\\sqrt{2}}\\alpha^{3/2}(2-\\alpha\n                     r)\\exp(-\\alpha r/2)$\n\n\n  3       $\\sqrt{\\frac{4}{27}}\\alpha^{3/2}(1-2\\alpha\n          r/3+2\\alpha^{2}r^{2}/27)\\exp(-\\alpha r/3)$\n</code></pre> One possible choice for the radial functions \\(R_{\\mathrm{r}}(r)\\)   associated with different values of \\(r\\): the set of solutions to the   radial part of the hydrogenic Schr\u00f6dinger equation for \\(l=0\\), i.e.,   the radial parts of the 1s, 2s, 3s...\u00a0orbitals, where   \\(\\alpha=Z/a={\\tt zona}\\). ::: :::"},{"location":"user_guide/wannier90/projections/#projections-via-the-scdm-k-method-in-pw2wannier90","title":"Projections via the SCDM-k method in pw2wannier90","text":"<p>For many systems, such as aperiodic systems, crystals with defects, or novel materials with complex band structure, it may be extremely hard to identify a-priori a good initial guess for the projection functions used to generate the \\(A_{mn}^{(\\mathbf{k})}\\) matrices. In these cases, one can use a different approach, known as the SCDM-k method<sup>1</sup>, based on a QR factorization with column pivoting (QRCP) of the density matrix from the self-consistent field calculation, which allows one to avoid the tedious step of specifying a projection block altogether, hence to avoid . This method is robust in generating well localised function with the correct spatial orientations and in general in finding the global minimum of the spread functional \\(\\Omega\\). Any electronic-structure code should in principle be able to implement the SCDM-k method within their interface with Wannier90, however at the moment (develop branch on the GitHub repository July 2019) only the Quantum ESPRESSO package has this capability implemented in the <code>pw2wannier90</code> interface program. Moreover, the <code>pw2wannier90</code> interface program supports also the SCDM-k method for spin-noncollinear systems. The SCDM-k can operate in two modes:</p> <ol> <li> <p>In isolation, i.e., without performing a subsequent Wannier90     optimisation (not recommended). This can be achieved by setting     <code>num_iter=0</code> and <code>dis_num_iter=0</code> in the <code>&lt;seedname&gt;.win</code> input     file. The rationale behind this is that in general the projection     functions obtained with the SCDM-k are already well localised     with the correct spatial orientations. However, the spreads of the     resulting functions are usually larger than the MLWFs ones.</p> </li> <li> <p>In combination with the Marzari-Vanderbilt (recommended option). In     this case, the SCDM-k is only used to generate the initial     \\(A_{mn}^{(\\mathbf{k})}\\) matrices as a replacement scheme for the     projection block.</p> </li> </ol> <p>The following keywords need to be specified in the <code>pw2wannier90.x</code> input file <code>&lt;seedname&gt;.pw2wan</code>: <code>scdm_proj</code> <code>scdm_entanglement</code> <code>scdm_mu</code> <code>scdm_sigma</code></p>"},{"location":"user_guide/wannier90/projections/#sec:proj_pdwf","title":"Projections via pseudo-atomic orbitals in pw2wannier90","text":"<p>When generating pseudopotentials, often the atomic wavefunctions of isolated atom are pseudized and bundled together with the pseudopotential files. These orbitals are often used for computing the projectabilities, for instance, measuring orbital contributions to band structures. Instead of manually specifying the initial projections in the <code>projections</code> block, one can use these pseudo-atomic orbitals to automate the initial projection process.</p> <p>Currently (July 2023), this functionality is implemented in the [quantum-espresso]{.smallcaps} interface, but in principle it can be done in any other interface as well. In the following, we will use the [quantum-espresso]{.smallcaps} interface as an example to illustrate the whole procedure.</p> <p>To activate pseudo-atomic orbital projection, one needs to set <code>auto_projections = .true.</code> in the <code>win</code> file, and remove the <code>projections</code> block.</p> <p>Then in the <code>pw2wannier90</code> input file, one needs to add an additional tag <code>atom_proj = .true.</code>. This will ask <code>pw2wannier90</code> to read the pseudo-atomic orbitals from the pseudopotential files, and use them to compute the <code>amn</code> file.</p> <p>Some times, one may want to exclude semi-core states from Wannierisation, for such cases, one can inspect the stdout of <code>pw2wannier90</code>, which will print the orbitals used for computing <code>amn</code>, e.g.,</p> <p><code></code></p> <p>-------------------------------------\\ *** Compute A with atomic projectors\\ -------------------------------------\\ Use atomic projectors from UPF\\ \\ (read from pseudopotential files):\\ state # 1: atom 1 (C ), wfc 1 (l=0 m= 1)\\ state # 2: atom 1 (C ), wfc 2 (l=1 m= 1)\\ state # 3: atom 1 (C ), wfc 2 (l=1 m= 2)\\ state # 4: atom 1 (C ), wfc 2 (l=1 m= 3)\\ state # 5: atom 2 (C ), wfc 1 (l=0 m= 1)\\ state # 6: atom 2 (C ), wfc 2 (l=1 m= 1)\\ state # 7: atom 2 (C ), wfc 2 (l=1 m= 2)\\ state # 8: atom 2 (C ), wfc 2 (l=1 m= 3)\\</p> <p>Here it shows that there are two carbon atoms, each with one \\(s\\) and three \\(p\\) orbitals. If one wants to exclude specific orbital(s), there is an additional input <code>atom_proj_exclude</code>, which accept a list of integers, e.g.,</p> <p><code>atom_proj_exclude = 1 5</code></p> <p>which will exclude the two \\(s\\) orbitals from computing <code>amn</code>.</p>"},{"location":"user_guide/wannier90/projections/#advanced-usage","title":"Advanced usage","text":"<p>If the pseudopotential orbitals are not enough, one could also generate a custom set of orbitals, and ask <code>pw2wannier90</code> to use them for computing <code>amn</code>. This can be done by setting</p> <p><code>atom_proj_dir = \u2019./ext_proj\u2019</code></p> <p>where the directory <code>ext_proj</code> contains the orbitals for all the atomic species used in the calculation. For example, for a silicon calculation, the directory <code>ext_proj</code> should contain a file named <code>Si.dat</code>. The format of the file is:</p> <ol> <li> <p>The first line contains two integers: the number of radial grid     points (\\(n_g\\)) and the number of projectors (\\(n_p\\)), e.g.,</p> <pre><code>1141 2\n</code></pre> <p>which means the radial grid has \\(n_g = 1141\\) points, and there are \\(n_p = 3\\) projectors.</p> </li> <li> <p>The second line contains \\(n_p\\) integers specifying the angular     momentums of all the projectors, e.g.,</p> <pre><code>0 1\n</code></pre> <p>standing for the two projectors having \\(s\\) and \\(p\\) characters, respectively.</p> </li> <li> <p>The rest of the file contains \\(n_g\\) rows of the radial wavefunctions     of the projectors. There are \\(2+n_p\\) columns: the first column is     the \\(x\\)-grid, the second column is the \\(r\\)-grid in Bohr unit, and     they are related by \\(r = \\exp(x)\\). The rest are \\(n_p\\) columns of the     radial wavefunctions of the projectors,</p> <pre><code>-9.639057329615259 0.000065134426111 3.32211124436945e-05 1.86840239681223e-09\n-9.626557329615258 0.000065953716334 3.363898259696903e-05 1.915701228607072e-09\n-9.614057329615258 0.000066783311958 3.406210890972733e-05 1.964197436025957e-09\n...\n</code></pre> <p>Inside <code>pw2wannier90.x</code>, the radial wavefunction will be read and multiplied by spherical harmonics to form the actual projectors.</p> <p>For a practical example of extracting pseudo-atomic orbitals from UPF file and writing to a <code>pw2wannier90</code>-recognizable <code>.dat</code> file, see the script <code>utility/write_pdwf_projectors.py</code>.</p> <p>For an actual example of a <code>Si.dat</code> file for silicon, see the file <code>examples/example35/ext_proj/Si.dat</code>.</p> </li> </ol> <ol> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/sample_inputs/","title":"Sample Input Files","text":""},{"location":"user_guide/wannier90/sample_inputs/#master-input-file-seednamewin","title":"Master input file: <code>seedname.win</code>","text":"<pre><code>num_wann          : 4 \nmp_grid           : 4 4 4 \nnum_iter          : 100\npostproc_setup    : true\n\nbegin unit_cell_cart\nang\n-1.61 0.00 1.61\n 0.00 1.61 1.61\n-1.61 1.61 0.00\nend unit_cell_cart\n\nbegin atoms_frac\nC   -0.125  -0.125  -0.125\nC    0.125   0.125   0.125\nend atoms_frac\n\nbands_plot        : true\nbands_num_points  : 100\nbands_plot_format : gnuplot\n\nbegin kpoint_path\nL 0.50000 0.50000 0.50000 G 0.00000 0.00000 0.00000\nG 0.00000 0.00000 0.00000 X 0.50000 0.00000 0.50000\nX 0.50000 0.00000 0.50000 K 0.62500 0.25000 0.62500\nend kpoint_path\n\nbegin projections\nC:l=0,l=1\nend projections\n\nbegin kpoints\n0.00 0.00 0.00\n0.00 0.00 0.25\n0.00 0.50 0.50\n .\n .\n .\n0.75 0.75 0.50\n0.75 0.75 0.75\nend kpoints\n</code></pre>"},{"location":"user_guide/wannier90/sample_inputs/#seednamennkp","title":"<code>seedname.nnkp</code>","text":"<p>Running <code>wannier90</code>\u00a0on the above input file would generate the following <code>nnkp</code> file:</p> <pre><code>File written on  9Feb2006 at 15:13: 9\n\ncalc_only_A   :  F\n\nbegin real_lattice\n  -1.612340   0.000000   1.612340\n   0.000000   1.612340   1.612340\n  -1.612340   1.612340   0.000000\nend real_lattice\n\nbegin recip_lattice\n  -1.951300  -1.951300   1.951300\n   1.951300   1.951300   1.951300\n  -1.951300   1.951300  -1.951300\nend recip_lattice\n\nbegin kpoints\n     64\n  0.00000   0.00000   0.00000   \n  0.00000   0.25000   0.00000   \n  0.00000   0.50000   0.00000   \n  0.00000   0.75000   0.00000   \n  0.25000   0.00000   0.00000   \n  .\n  .\n  .\n  0.50000   0.75000   0.75000   \n  0.75000   0.00000   0.75000   \n  0.75000   0.25000   0.75000   \n  0.75000   0.50000   0.75000   \n  0.75000   0.75000   0.75000     \nend kpoints\n\nbegin projections\n   8\n  -0.12500   -0.12500   -0.12500     0  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  2  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  3  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     0  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  2  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  3  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \nend projections\n\nbegin nnkpts\n    8\n  1     2      0   0   0\n  1     4      0  -1   0\n  1     5      0   0   0\n  1    13     -1   0   0\n  1    17      0   0   0\n  1    22      0   0   0\n  1    49      0   0  -1\n  1    64     -1  -1  -1\n  2     1      0   0   0\n  2     3      0   0   0\n  2     6      0   0   0\n  2    14     -1   0   0\n  2    18      0   0   0\n  2    23      0   0   0\n  2    50      0   0  -1\n  2    61     -1   0  -1\n  .\n  .\n  .\n 64     1      1   1   1\n 64    16      0   0   1\n 64    43      0   0   0\n 64    48      0   0   0\n 64    52      1   0   0\n 64    60      0   0   0\n 64    61      0   1   0\n 64    63      0   0   0\nend nnkpts\n\nbegin exclude_bands \n   4 \n   1 \n   2 \n   3\n   4\nend exclude_bands\n</code></pre>"},{"location":"user_guide/wannier90/transport/","title":"Transport Calculations with <code>wannier90</code>","text":"<p>By setting \\(\\verb#transport#=\\verb#TRUE#\\), <code>wannier90</code>\u00a0will calculate the quantum conductance and density of states of a one-dimensional system. The results will be written to files <code>seedname_qc.dat</code> and <code>seedname_dos.dat</code>, respectively.</p> <p>The system for which transport properties are calculated is determined by the keyword <code>transport_mode</code>.</p>"},{"location":"user_guide/wannier90/transport/#transport_mode-bulk","title":"<code>transport_mode = bulk</code>","text":"<p>Quantum conductance and density of states are calculated for a perfectly periodic one-dimensional conductor. If \\(\\verb#tran_read_ht#=\\verb#FALSE#\\) the transport properties are calculated using the Hamiltonian in the Wannier function basis of the system found by <code>wannier90</code>. Setting \\(\\verb#tran_read_ht#=\\verb#TRUE#\\) allows the user to provide an external Hamiltonian matrix file <code>seedname_htB.dat</code>, from which the properties are found. See Section\u00a02.9 for more details of the keywords required for such calculations.</p>"},{"location":"user_guide/wannier90/transport/#transport_mode-lcr","title":"<code>transport_mode = lcr</code>","text":"<p>Quantum conductance and density of states are calculated for a system where semi-infinite, left and right leads are connected through a central conductor region. This is known as the lcr system. Details of the method is described in Ref. <sup>1</sup>.</p> <p>In <code>wannier90</code>\u00a0two options exist for performing such calculations:</p> <ul> <li> <p>If \\(\\verb#tran_read_ht#=\\verb#TRUE#\\) the external Hamiltonian files     <code>seedname_htL.dat, seedname_htLC.dat, seedname_htC.dat, seedname_htCR.dat, seedname_htR.dat</code>     are read and used to compute the transport properties.</p> </li> <li> <p>If \\(\\verb#tran_read_ht#=\\verb#FALSE#\\), then the transport     calculation is performed automatically using the Wannier functions     as a basis and the 2c2 geometry described in     Section\u00a07.3.</p> </li> </ul>"},{"location":"user_guide/wannier90/transport/#sec:2c2","title":"Automated lcr Transport Calculations: The 2c2 Geometry","text":"<p>Calculations using the 2c2 geometry provide a method to calculate the transport properties of an lcr system from a single <code>wannier90</code>\u00a0calculation. The Hamiltonian matrices which the five external files provide in the \\(\\verb#tran_read_ht#=\\verb#TRUE#\\) case are instead built from the Wannier function basis directly. As such, strict rules apply to the system geometry, which is shown in Figure\u00a07.1. These rules are as follows:</p> <ul> <li> <p>Left and right leads must be identical and periodic.</p> </li> <li> <p>Supercell must contain two principal layers (PLs) of lead on the     left, a central conductor region and two principal layers of lead on     the right.</p> </li> <li> <p>The conductor region must contain enough lead such that the disorder     does not affect the principal layers of lead either side.</p> </li> <li> <p>A single k-point (Gamma) must be used.</p> </li> </ul> <p></p> <p>In order to build the Hamiltonians, Wannier functions are first sorted according to position and then type if a number of Wannier functions exist with a similar centre (eg. d-orbital type Wannier functions centred on a Cu atom). Next, consistent parities of Wannier function are enforced. To distingiush between different types of Wannier function and assertain relative parities, a signature of each Wannier function is computed. The signature is formed of 20 integrals which have different spatial dependence. They are given by:</p> \\[I=\\frac{1}{V}\\int_V g(\\mathbf{r})w(\\mathbf{r})d\\mathbf{r} \\label{eq:sig_ints}\\] <p>where \\(V\\) is the volume of the cell, \\(w(\\mathbf{r})\\) is the Wannier function and \\(g(\\mathbf{r})\\) are the set of functions:</p> <p>\\(\\(\\begin{aligned} g(\\mathbf{r})=&amp;\\left\\lbrace1,\\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right),                                              \\sin\\left(\\frac{2\\pi (y-y_c)}{L_y}\\right),                                              \\sin\\left(\\frac{2\\pi (z-z_c)}{L_z}\\right),                                              \\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right)                                              \\sin\\left(\\frac{2\\pi (y-y_c)}{L_y}\\right),\\right.\\nonumber \\\\                                            &amp;\\left.\\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right)                                              \\sin\\left(\\frac{2\\pi (z-z_c)}{L_z}\\right),                                              ... \\right\\rbrace \\label{eq:g(r)} \\end{aligned}\\)\\) upto third order in powers of sines. Here, the supercell has dimension \\((L_x,L_y,L_z)\\) and the Wannier function has centre \\(\\mathbf{r}_c=(x_c,y_c,z_c)\\). Each of these integrals may be written as linear combinations of the following sums:</p> \\[S_n(\\mathbf{G})=\\displaystyle{e^{i\\mathbf{G.r}_{c}}\\sum_{m}U_{mn}\\tilde{u}_{m\\Gamma}^{*}(\\mathbf{G})}\\] <p>where \\(n\\) and \\(m\\) are the Wannier function and band indexes, \\(\\mathbf{G}\\) is a G-vector, \\(U_{mn}\\) is the unitary matrix that transforms from the Bloch reopresentation of the system to the maximally-localised Wannier function basis and \\(\\tilde{u}_{m\\Gamma}^{*}(\\mathbf{G})\\) are the conjugates of the Fourier transforms of the periodic parts of the Bloch states at the \\(\\Gamma\\!\\) -point. The complete set of \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are often outputted by plane-wave DFT codes. However, to calculate the 20 signature integrals, only 32 specific \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are required. These are found in an additional file (<code>seedname.unkg</code>) that should be provided by the interface between the DFT code and <code>wannier90</code>\u00a0. A detailed description of this file may be found in Section\u00a08.32{reference-type=\"ref\" reference=\"sec:files_unkg\"}.</p> <p>Additionally, the following keywords are also required in the input file:</p> <ul> <li> <p><code>tran_num_ll</code> : The number of Wannier functions in a principal     layer.</p> </li> <li> <p><code>tran_num_cell_ll</code> : The number of unit cells in one principal layer     of lead</p> </li> </ul> <p>A further parameter related to these calculations is <code>tran_group_threshold</code>.</p> <p>Examples of how 2c2 calculations are preformed can be found in the <code>wannier90</code>\u00a0Tutorial.</p> <ol> <li> <p>Marco Buongiorno Nardelli. Electronic transport in extended systems: application to carbon nanotubes. Phys. Rev. B, 60:7828, 1999.\u00a0\u21a9</p> </li> </ol>"}]}